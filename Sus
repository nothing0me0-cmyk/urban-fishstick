-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âš¡ SOLO LEVELING SYSTEM - ULTIMATE PERFECTED EDITION V2 âš¡
-- Full VFX | Rampage | Awakening | Behind You | All Effects
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“Š CORE DATA STRUCTURE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local PlayerData = {
    stats = {
        strength = 0,
        agility = 0,
        perception = 0,
        vitality = 0,
        intelligence = 0
    },
    level = 1,
    xp = 0,
    maxHP = 100,
    availablePoints = 5,
    
    shadowStep = {
        level = 1,
        uses = 0,
        unlocked = false,
        cooldown = 0,
        isActive = false
    },
    
    rampage = {
        unlocked = false,
        isActive = false,
        duration = 90, -- 1min 30sec base
        cooldown = 0,
        maxCooldown = 300,
        killsRequired = 5,
        currentKills = 0
    },
    
    behindYou = {
        cooldown = 0,
        maxCooldown = 20,
        minCooldown = 5 -- Can go down to 5s with PER
    },
    
    combatEngagement = {},
    assistEngagement = {},
    hasSecondChance = true
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âš™ï¸ CONFIGURATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Config = {
    BASE_WALK_SPEED = 16,
    MAX_WALK_SPEED = 100,
    BASE_DASH_SPEED = 50,
    BASE_DASH_RANGE = 30,
    BASE_SHADOW_STEP_RANGE = 50,
    BASE_SHADOW_STEP_COOLDOWN = 10,
    
    LEVEL_CAP = 100,
    MAX_STAT_VALUE = 100,
    POINTS_PER_LEVEL = 3,
    SHADOW_STEP_UNLOCK_LEVEL = 10,
    RAMPAGE_UNLOCK_LEVEL = 25,
    
    COMBAT_TIMEOUT = 5,
    MIN_HITS_FOR_KILL = 2,
    ASSIST_RANGE = 50,
    ASSIST_TIME_WINDOW = 10,
    
    BASE_KILL_XP = 200,
    ASSIST_XP_MULTIPLIER = 0.3,
    
    BEHIND_YOU_MIN_RANGE = 100,
    BEHIND_YOU_MAX_RANGE = 500,
    
    -- VFX Settings
    VFX = {
        SHADOW_PORTAL_PARTICLES = 20,
        LEVEL_UP_PARTICLES = 30,
        STAT_UPGRADE_ORBS = 8,
        RAMPAGE_AURA_DENSITY = 25,
        BEHIND_YOU_SMOKE = 15,
        CAMERA_SHAKE_INTENSITY = 5
    },
    
    STAT_CURVES = {
        strength = {
            damagePerPoint = 2,
            diminishingStart = 50,
            diminishingFactor = 0.8
        },
        agility = {
            walkSpeedPerPoint = 0.84,
            dashSpeedPerPoint = 0.04
        },
        perception = {
            rangePerPoint = 10,
            dashRangePerPoint = 0.05,
            cooldownReductionPerPoint = 0.02,
            maxCooldownReduction = 0.6,
            rampageDurationPerPoint = 2.1, -- +2.1s per point (max +210s = 5min total)
            behindYouCDReductionPerPoint = 0.15 -- -15% per point
        },
        vitality = {
            hpPerPoint = 20,
            regenPerPoint = 0.5,
            secondChanceThreshold = 10
        },
        intelligence = {
            xpPerPoint = 50,
            cooldownBonusPerPoint = 0.01
        }
    }
}

-- Calculated values
local dashSpeed = Config.BASE_DASH_SPEED
local dashRange = Config.BASE_DASH_RANGE
local shadowStepRange = Config.BASE_SHADOW_STEP_RANGE
local shadowStepMaxCooldown = Config.BASE_SHADOW_STEP_COOLDOWN

-- UI References
local mainPart, notifPart, isVisible, acceptedNotification = nil, nil, false, false
local levelValueLabel, xpBar, xpTextLabel, rankLabel, titleLabel, pointsValueLabel
local hpBar, hpTextLabel, shadowStepButton, cooldownBar, statsButton, ssLevelLabel
local classLabel, statusLabel, rampageButton, behindYouButton, rampageKillLabel

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ¨ RANK & STAT DATA
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local RankData = {
    {name = "E-RANK", level = 1, color = Color3.fromRGB(176, 176, 176), title = "The Weakest Hunter", status = "NORMAL"},
    {name = "D-RANK", level = 10, color = Color3.fromRGB(79, 195, 247), title = "Awakened", status = "NORMAL"},
    {name = "C-RANK", level = 20, color = Color3.fromRGB(76, 175, 80), title = "Elite Hunter", status = "NORMAL"},
    {name = "B-RANK", level = 35, color = Color3.fromRGB(255, 193, 7), title = "Elite Hunter", status = "HIGH"},
    {name = "A-RANK", level = 50, color = Color3.fromRGB(255, 112, 67), title = "Apex Hunter", status = "RARE"},
    {name = "S-RANK", level = 70, color = Color3.fromRGB(211, 47, 47), title = "National Threat", status = "EXTREMELY RARE"},
    {name = "NATIONAL", level = 90, color = Color3.fromRGB(138, 43, 226), title = "National Power", status = "CLASSIFIED"},
    {name = "MONARCH", level = 100, color = Color3.fromRGB(0, 0, 0), title = "Shadow Monarch", status = "UNKNOWN"}
}

local StatInfo = {
    strength = {
        name = "Strength", abbr = "STR", color = Color3.fromRGB(239, 68, 68),
        title = "ğŸŸ¥ Physical Power",
        description = "Increases physical power and combat effectiveness.\n\nâ€¢ +2% damage per point\nâ€¢ Diminishing returns after 50 points\nâ€¢ Enhanced melee impact\nâ€¢ Stronger combat presence",
        getEffect = function(val)
            local dmg = val * Config.STAT_CURVES.strength.damagePerPoint
            if val > Config.STAT_CURVES.strength.diminishingStart then
                local excess = val - Config.STAT_CURVES.strength.diminishingStart
                dmg = Config.STAT_CURVES.strength.diminishingStart * Config.STAT_CURVES.strength.damagePerPoint
                dmg = dmg + (excess * Config.STAT_CURVES.strength.damagePerPoint * Config.STAT_CURVES.strength.diminishingFactor)
            end
            return string.format("+%d%% DMG", math.floor(dmg))
        end
    },
    vitality = {
        name = "Vitality", abbr = "VIT", color = Color3.fromRGB(168, 85, 247),
        title = "ğŸŸª Body Toughness",
        description = "Improves endurance and survivability.\n\nâ€¢ +20 HP per point\nâ€¢ +0.5 HP regen per second per point\nâ€¢ Second Chance (requires 10+ VIT)\nâ€¢ Better sustain in combat",
        getEffect = function(val) return string.format("+%d HP", val * Config.STAT_CURVES.vitality.hpPerPoint) end
    },
    agility = {
        name = "Agility", abbr = "AGI", color = Color3.fromRGB(34, 197, 94),
        title = "ğŸŸ© Speed & Movement",
        description = "Increases movement and dash speed.\n\nâ€¢ Walk speed increases toward cap (100)\nâ€¢ +4% dash speed per point\nâ€¢ Faster evasive movement\nâ€¢ Enhanced mobility",
        getEffect = function(val) return string.format("+%d SPD", math.floor(val * Config.STAT_CURVES.agility.walkSpeedPerPoint)) end
    },
    intelligence = {
        name = "Intelligence", abbr = "INT", color = Color3.fromRGB(59, 130, 246),
        title = "ğŸŸ¦ Tactical Mind",
        description = "Increases XP gain and ability efficiency.\n\nâ€¢ +50 XP per kill per point\nâ€¢ -1% ability cooldown per point\nâ€¢ Faster progression\nâ€¢ Efficient growth",
        getEffect = function(val) return string.format("+%d XP", val * Config.STAT_CURVES.intelligence.xpPerPoint) end
    },
    perception = {
        name = "Perception", abbr = "PER", color = Color3.fromRGB(250, 204, 21),
        title = "ğŸŸ¨ Battle Control",
        description = "Improves ability range and efficiency.\n\nâ€¢ +10 studs Shadow Step range\nâ€¢ +5% dash range per point\nâ€¢ -2% Shadow Step cooldown per point\nâ€¢ +2.1s Rampage duration per point (max 5min)\nâ€¢ -15% Behind You cooldown per point\nâ€¢ Max 60% cooldown reduction",
        getEffect = function(val) return string.format("+%d RNG", val * 10) end
    }
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ’ª STAT CALCULATION MODULE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local StatCalculator = {}

function StatCalculator.applyStatEffects()
    if not humanoid then return end
    
    local stats = PlayerData.stats
    local curves = Config.STAT_CURVES
    
    -- Store health percentage BEFORE changes
    local healthPercent = humanoid.Health / humanoid.MaxHealth
    
    -- Agility: Movement speed with cap
    local agiSpeed = Config.BASE_WALK_SPEED + (stats.agility * curves.agility.walkSpeedPerPoint)
    humanoid.WalkSpeed = math.min(agiSpeed, Config.MAX_WALK_SPEED)
    dashSpeed = Config.BASE_DASH_SPEED * (1 + stats.agility * curves.agility.dashSpeedPerPoint)
    
    -- Perception: Range and cooldown
    dashRange = Config.BASE_DASH_RANGE * (1 + stats.perception * curves.perception.dashRangePerPoint)
    shadowStepRange = Config.BASE_SHADOW_STEP_RANGE + (stats.perception * curves.perception.rangePerPoint)
    
    local cdReduction = math.clamp(
        stats.perception * curves.perception.cooldownReductionPerPoint,
        0,
        curves.perception.maxCooldownReduction
    )
    shadowStepMaxCooldown = Config.BASE_SHADOW_STEP_COOLDOWN * (1 - cdReduction)
    
    -- Intelligence: Cooldown bonus
    local intBonus = 1 - (stats.intelligence * curves.intelligence.cooldownBonusPerPoint)
    shadowStepMaxCooldown = shadowStepMaxCooldown * math.max(intBonus, 0.5)
    
    -- Perception: Rampage duration (90s base + 2.1s per point, max 300s = 5min)
    PlayerData.rampage.duration = math.min(90 + (stats.perception * curves.perception.rampageDurationPerPoint), 300)
    
    -- Behind You cooldown scaling with PER (20s -> 5s)
    local behindYouReduction = math.clamp(stats.perception * curves.perception.behindYouCDReductionPerPoint, 0, 0.75)
    PlayerData.behindYou.maxCooldown = 20 * (1 - behindYouReduction)
    PlayerData.behindYou.maxCooldown = math.max(PlayerData.behindYou.maxCooldown, PlayerData.behindYou.minCooldown)
    
    -- Vitality: HP with percentage preservation
    PlayerData.maxHP = 100 + (stats.vitality * curves.vitality.hpPerPoint)
    humanoid.MaxHealth = PlayerData.maxHP
    
    -- Restore health proportionally
    humanoid.Health = PlayerData.maxHP * healthPercent
    
    -- Second Chance check
    PlayerData.hasSecondChance = stats.vitality >= curves.vitality.secondChanceThreshold
end

function StatCalculator.getDamageMultiplier()
    local str = PlayerData.stats.strength
    local curve = Config.STAT_CURVES.strength
    
    local damage = str * curve.damagePerPoint
    if str > curve.diminishingStart then
        local excess = str - curve.diminishingStart
        damage = curve.diminishingStart * curve.damagePerPoint
        damage = damage + (excess * curve.damagePerPoint * curve.diminishingFactor)
    end
    
    return 1 + (damage / 100)
end

function StatCalculator.getXPBonus()
    return PlayerData.stats.intelligence * Config.STAT_CURVES.intelligence.xpPerPoint
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“ˆ LEVEL & RANK SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local LevelSystem = {}

function LevelSystem.calculateRequiredXP(level)
    return math.floor(100 * (level ^ 1.15))
end

function LevelSystem.getCurrentRank()
    for i = #RankData, 1, -1 do
        if PlayerData.level >= RankData[i].level then
            return RankData[i]
        end
    end
    return RankData[1]
end

function LevelSystem.getCurrentClass()
    if PlayerData.level >= 100 then return "Shadow Monarch"
    elseif PlayerData.level >= 71 then return "Shadow Commander"
    elseif PlayerData.level >= 41 then return "Shadow Warrior"
    elseif PlayerData.level >= 21 then return "Shadow Adept"
    else return "Unclassified" end
end

function LevelSystem.grantXP(amount)
    if PlayerData.rampage.isActive then return end
    
    PlayerData.xp = PlayerData.xp + amount
    
    local maxXP = LevelSystem.calculateRequiredXP(PlayerData.level)
    
    while PlayerData.xp >= maxXP and PlayerData.level < Config.LEVEL_CAP do
        PlayerData.xp = PlayerData.xp - maxXP
        PlayerData.level = PlayerData.level + 1
        PlayerData.availablePoints = PlayerData.availablePoints + Config.POINTS_PER_LEVEL
        
        EffectsModule.createLevelUpEffect()
        
        -- Full heal on level up (preserve percentage method)
        local oldMax = humanoid.MaxHealth
        PlayerData.maxHP = 100 + (PlayerData.stats.vitality * Config.STAT_CURVES.vitality.hpPerPoint)
        humanoid.MaxHealth = PlayerData.maxHP
        humanoid.Health = PlayerData.maxHP
        
        -- Unlock Shadow Step
        if PlayerData.level >= Config.SHADOW_STEP_UNLOCK_LEVEL and not PlayerData.shadowStep.unlocked then
            PlayerData.shadowStep.unlocked = true
            if shadowStepButton then
                shadowStepButton.Visible = true
            end
        end
        
        -- Unlock Rampage
        if PlayerData.level >= Config.RAMPAGE_UNLOCK_LEVEL and not PlayerData.rampage.unlocked then
            PlayerData.rampage.unlocked = true
            if rampageButton then
                rampageButton.Visible = true
            end
            EffectsModule.createRampageUnlockEffect()
        end
        
        maxXP = LevelSystem.calculateRequiredXP(PlayerData.level)
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âš”ï¸ COMBAT TRACKING MODULE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local CombatModule = {}

function CombatModule.trackCombatEngagement(victim)
    if not victim or not victim.UserId then return end
    
    local userId = victim.UserId
    local currentTime = tick()
    
    if not PlayerData.combatEngagement[userId] then
        PlayerData.combatEngagement[userId] = {
            lastHit = currentTime,
            hitCount = 1,
            totalDamage = 0
        }
    else
        PlayerData.combatEngagement[userId].lastHit = currentTime
        PlayerData.combatEngagement[userId].hitCount = PlayerData.combatEngagement[userId].hitCount + 1
    end
end

function CombatModule.trackAssistEngagement(victim, attacker)
    if not victim or not attacker or attacker == player then return end
    
    local userId = victim.UserId
    local currentTime = tick()
    
    if not PlayerData.assistEngagement[userId] then
        PlayerData.assistEngagement[userId] = {
            lastHit = currentTime,
            primaryAttacker = attacker,
            playerContributed = false
        }
    else
        PlayerData.assistEngagement[userId].lastHit = currentTime
    end
end

function CombatModule.validateKill(victimUserId)
    local engagement = PlayerData.combatEngagement[victimUserId]
    if not engagement then return false end
    
    local timeSinceHit = tick() - engagement.lastHit
    return timeSinceHit <= Config.COMBAT_TIMEOUT and engagement.hitCount >= Config.MIN_HITS_FOR_KILL
end

function CombatModule.validateAssist(victimUserId)
    local assist = PlayerData.assistEngagement[victimUserId]
    if not assist then return false end
    
    local timeSinceHit = tick() - assist.lastHit
    return timeSinceHit <= Config.ASSIST_TIME_WINDOW and assist.playerContributed
end

function CombatModule.onPlayerKilled(victim)
    if not victim or not victim.UserId then return end
    
    local userId = victim.UserId
    local totalXP = 0
    
    -- Check for primary kill
    if CombatModule.validateKill(userId) then
        totalXP = Config.BASE_KILL_XP + StatCalculator.getXPBonus()
        LevelSystem.grantXP(totalXP)
        
        -- Increment Rampage kill counter
        if PlayerData.rampage.cooldown > 0 then
            PlayerData.rampage.currentKills = PlayerData.rampage.currentKills + 1
            
            if PlayerData.rampage.currentKills >= PlayerData.rampage.killsRequired then
                PlayerData.rampage.cooldown = 0
                PlayerData.rampage.currentKills = 0
                EffectsModule.spawnSystemText("RAMPAGE READY", Vector3.new(0, 3, 0))
            end
        end
        
        if rootPart then
            EffectsModule.createXPPopup(totalXP, rootPart.Position, "KILL")
        end
        
        PlayerData.combatEngagement[userId] = nil
        
    -- Check for assist
    elseif CombatModule.validateAssist(userId) then
        totalXP = math.floor((Config.BASE_KILL_XP + StatCalculator.getXPBonus()) * Config.ASSIST_XP_MULTIPLIER)
        LevelSystem.grantXP(totalXP)
        
        if rootPart then
            EffectsModule.createXPPopup(totalXP, rootPart.Position, "ASSIST")
        end
        
        PlayerData.assistEngagement[userId] = nil
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸŒ‘ ABILITY MODULE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local AbilityModule = {}

function AbilityModule.performShadowStep()
    if PlayerData.shadowStep.isActive or 
       PlayerData.shadowStep.cooldown > 0 or 
       not PlayerData.shadowStep.unlocked or
       not rootPart or
       PlayerData.rampage.isActive then
        return
    end
    
    PlayerData.shadowStep.isActive = true
    
    local camera = workspace.CurrentCamera
    local lookVector = camera.CFrame.LookVector
    local targetPos = rootPart.Position + (lookVector * shadowStepRange)
    
    -- Raycast check
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {character}
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    
    local ray = workspace:Raycast(rootPart.Position, lookVector * shadowStepRange, rayParams)
    if ray then
        targetPos = ray.Position + (ray.Normal * 3)
    end
    
    -- Start VFX
    task.spawn(function()
        EffectsModule.createShadowPortal(rootPart.Position)
        EffectsModule.createShadowStepTrail(rootPart.Position, targetPos)
    end)
    
    -- Teleport
    rootPart.CFrame = CFrame.new(targetPos, targetPos + lookVector)
    
    -- End VFX
    task.spawn(function()
        EffectsModule.createShadowPortal(targetPos)
    end)
    
    -- Level up Shadow Step
    PlayerData.shadowStep.uses = PlayerData.shadowStep.uses + 1
    local usesNeeded = PlayerData.shadowStep.level <= 10 and 5 or 8
    
    if PlayerData.shadowStep.uses >= usesNeeded and PlayerData.shadowStep.level < 50 then
        PlayerData.shadowStep.level = PlayerData.shadowStep.level + 1
        PlayerData.shadowStep.uses = 0
        task.spawn(function()
            EffectsModule.createSkillLevelUpEffect("SHADOW STEP")
        end)
    end
    
    PlayerData.shadowStep.cooldown = shadowStepMaxCooldown
    PlayerData.shadowStep.isActive = false
end

function AbilityModule.performDash()
    if not rootPart or not humanoid then return end
    
    local camera = workspace.CurrentCamera
    local lookVector = camera.CFrame.LookVector
    
    task.spawn(function()
        EffectsModule.createDashTrail()
    end)
    
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(4000, 0, 4000)
    bodyVelocity.Velocity = lookVector * dashSpeed
    bodyVelocity.Parent = rootPart
    
    Debris:AddItem(bodyVelocity, 0.3)
end

function AbilityModule.activateRampage()
    if PlayerData.rampage.isActive or 
       PlayerData.rampage.cooldown > 0 or 
       not PlayerData.rampage.unlocked or
       not rootPart then
        return
    end
    
    -- Lock player
    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0
    
    -- Play awakening animation
    task.spawn(function()
        EffectsModule.createAwakeningSequence()
    end)
    
    task.wait(3)
    
    -- Activate Rampage
    PlayerData.rampage.isActive = true
    
    -- Override stats to max
    local originalStats = {}
    for stat, value in pairs(PlayerData.stats) do
        originalStats[stat] = value
        PlayerData.stats[stat] = Config.MAX_STAT_VALUE
    end
   
    -- Apply max effects
    humanoid.WalkSpeed = Config.MAX_WALK_SPEED
    
    -- Reset Shadow Step cooldown
    PlayerData.shadowStep.cooldown = 0
    
    -- Enable Behind You
    if behindYouButton then
        behindYouButton.Visible = true
    end
    
    -- Create aura
    task.spawn(function()
        EffectsModule.createRampageAura()
    end)
    
    -- Duration countdown
    task.wait(PlayerData.rampage.duration)
    
    -- Deactivate Rampage
    PlayerData.rampage.isActive = false
    
    -- Restore stats
    for stat, value in pairs(originalStats) do
        PlayerData.stats[stat] = value
    end
    
    -- Reapply normal effects
    StatCalculator.applyStatEffects()
    
    -- Disable Behind You
    if behindYouButton then
        behindYouButton.Visible = false
    end
    PlayerData.behindYou.cooldown = 0
    
    -- Set cooldown (must get 5 kills to reduce)
    PlayerData.rampage.cooldown = PlayerData.rampage.maxCooldown
    PlayerData.rampage.currentKills = 0
end

function AbilityModule.performBehindYou()
    if not PlayerData.rampage.isActive or 
       PlayerData.behindYou.cooldown > 0 or
       not rootPart then
        return
    end
    
    -- Find nearest player
    local nearestPlayer = nil
    local nearestDistance = math.huge
    
    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherRoot then
                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                if distance >= Config.BEHIND_YOU_MIN_RANGE and 
                   distance <= Config.BEHIND_YOU_MAX_RANGE and 
                   distance < nearestDistance then
                    nearestDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end
    
    if not nearestPlayer then return end
    
    local targetRoot = nearestPlayer.Character.HumanoidRootPart
    local startPos = rootPart.Position
    local targetPos = targetRoot.Position - (targetRoot.CFrame.LookVector * 5)
    
    -- Start animation
    local animationId = 15962326593
    local animation = Instance.new("Animation")
    animation.AnimationId = "rbxassetid://" .. animationId
    
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then
        animator = Instance.new("Animator")
        animator.Parent = humanoid
    end
    
    local animTrack = animator:LoadAnimation(animation)
    animTrack:Play()
    
    -- VFX in separate thread
    task.spawn(function()
        EffectsModule.createBehindYouEffect(startPos, targetPos)
    end)
    
    -- Teleport at halfway
    local animLength = animTrack.Length
    task.wait(animLength * 0.5)
    
    rootPart.CFrame = CFrame.new(targetPos, targetRoot.Position)
    
    -- Set cooldown
    PlayerData.behindYou.cooldown = PlayerData.behindYou.maxCooldown
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ¨ EFFECTS MODULE (OPTIMIZED VFX)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EffectsModule = {}

function EffectsModule.createXPPopup(amount, position, type)
    if PlayerData.rampage.isActive then return end
    
    local part = Instance.new("Part")
    part.Size = Vector3.new(5, 3, 0.1)
    part.Position = position + Vector3.new(0, 4, 0)
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Parent = workspace
    
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Size = UDim2.new(0, 300, 0, 150)
    billboardGui.StudsOffset = Vector3.new(0, 2, 0)
    billboardGui.AlwaysOnTop = true
    billboardGui.Parent = part
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.GothamBold
    label.TextSize = 36
    label.Parent = billboardGui
    
    if type == "KILL" then
        label.Text = "+" .. amount .. " XP"
        label.TextColor3 = Color3.fromRGB(34, 211, 238)
    elseif type == "ASSIST" then
        label.Text = "+" .. amount .. " XP [ASSIST]"
        label.TextColor3 = Color3.fromRGB(250, 204, 21)
        label.TextSize = 28
    end
    
    local particles = Instance.new("ParticleEmitter")
    particles.Texture = "rbxasset://textures/particles/sparkles_main.dds"
    particles.Rate = 50
    particles.Lifetime = NumberRange.new(0.5, 1)
    particles.Speed = NumberRange.new(5, 10)
    particles.Color = ColorSequence.new(label.TextColor3)
    particles.Size = NumberSequence.new(0.3)
    particles.Parent = part
    particles.Enabled = true
    
    task.delay(0.2, function()
        particles.Enabled = false
    end)
    
    TweenService:Create(billboardGui, TweenInfo.new(1.5), {StudsOffset = Vector3.new(0, 5, 0)}):Play()
    TweenService:Create(label, TweenInfo.new(1.5), {TextTransparency = 1}):Play()
    
    Debris:AddItem(part, 1.5)
end

function EffectsModule.createLevelUpEffect()
    if not rootPart then return end
    
    -- Screen flash
    local playerGui = player:WaitForChild("PlayerGui")
    local flash = Instance.new("Frame")
    flash.Size = UDim2.new(1, 0, 1, 0)
    flash.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
    flash.BackgroundTransparency = 0.2
    flash.BorderSizePixel = 0
    flash.ZIndex = 100
    flash.Parent = playerGui
    
    TweenService:Create(flash, TweenInfo.new(0.8), {BackgroundTransparency = 1}):Play()
    Debris:AddItem(flash, 0.8)
    
    -- Golden pillar of light
    local pillar = Instance.new("Part")
    pillar.Size = Vector3.new(8, 50, 8)
    pillar.Position = rootPart.Position
    pillar.Anchored = true
    pillar.CanCollide = false
    pillar.Material = Enum.Material.Neon
    pillar.Color = Color3.fromRGB(255, 215, 0)
    pillar.Transparency = 0.5
    pillar.Parent = workspace
    
    local mesh = Instance.new("CylinderMesh")
    mesh.Parent = pillar
    
    TweenService:Create(pillar, TweenInfo.new(1), {
        Transparency = 1,
        Size = Vector3.new(12, 50, 12)
    }):Play()
    
    -- Particle explosion
    for i = 1, Config.VFX.LEVEL_UP_PARTICLES do
        local part = Instance.new("Part")
        part.Size = Vector3.new(0.5, 0.5, 0.5)
        part.Position = rootPart.Position + Vector3.new(
            math.random(-3, 3),
            math.random(-2, 4),
            math.random(-3, 3)
        )
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(255, 215, 0)
        part.Parent = workspace
        
        TweenService:Create(part, TweenInfo.new(1), {
            Position = part.Position + Vector3.new(0, 8, 0),
            Transparency = 1,
            Size = Vector3.new(0.1, 0.1, 0.1)
        }):Play()
        
        Debris:AddItem(part, 1)
    end
    
    Debris:AddItem(pillar, 1)
end

function EffectsModule.createStatUpgradeEffect(statName)
    if not rootPart then return end
    
    local statColor = StatInfo[statName].color
    
    -- Orb that spirals around player
    for i = 1, Config.VFX.STAT_UPGRADE_ORBS do
        local angle = (i / Config.VFX.STAT_UPGRADE_ORBS) * math.pi * 2
        local part = Instance.new("Part")
        part.Size = Vector3.new(0.8, 0.8, 0.8)
        part.Shape = Enum.PartType.Ball
        part.Position = rootPart.Position + Vector3.new(
            math.cos(angle) * 3,
            2,
            math.sin(angle) * 3
        )
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.Color = statColor
        part.Parent = workspace
        
        local particles = Instance.new("ParticleEmitter")
        particles.Texture = "rbxasset://textures/particles/sparkles_main.dds"
        particles.Rate = 20
        particles.Lifetime = NumberRange.new(0.3, 0.6)
        particles.Speed = NumberRange.new(2, 4)
        particles.Color = ColorSequence.new(statColor)
        particles.Size = NumberSequence.new(0.2)
        particles.Parent = part
        
        TweenService:Create(part, TweenInfo.new(0.8), {
            Position = rootPart.Position + Vector3.new(0, 2, 0),
            Transparency = 1,
            Size = Vector3.new(0.2, 0.2, 0.2)
        }):Play()
        
        Debris:AddItem(part, 0.8)
    end
end

function EffectsModule.createShadowPortal(position)
    local portal = Instance.new("Part")
    portal.Size = Vector3.new(6, 0.4, 6)
    portal.Position = position
    portal.Anchored = true
    portal.CanCollide = false
    portal.Material = Enum.Material.Neon
    portal.Color = Color3.fromRGB(10, 10, 10)
    portal.Transparency = 0.2
    portal.Parent = workspace
    
    -- Purple rim
    local rim = Instance.new("Part")
    rim.Size = Vector3.new(7, 0.5, 7)
    rim.Position = position
    rim.Anchored = true
    rim.CanCollide = false
    rim.Material = Enum.Material.Neon
    rim.Color = Color3.fromRGB(138, 43, 226)
    rim.Transparency = 0.4
    rim.Parent = workspace
    
    local rimMesh = Instance.new("CylinderMesh")
    rimMesh.Parent = rim
    
    local portalMesh = Instance.new("CylinderMesh")
    portalMesh.Parent = portal
    
    -- Add particles
    for i = 1, Config.VFX.SHADOW_PORTAL_PARTICLES do
        local particle = Instance.new("Part")
        particle.Size = Vector3.new(0.3, 0.3, 0.3)
        particle.Position = position + Vector3.new(
            math.random(-3, 3),
            0.5,
            math.random(-3, 3)
        )
        particle.Anchored = true
        particle.CanCollide = false
        particle.Material = Enum.Material.Neon
        particle.Color = Color3.fromRGB(138, 43, 226)
        particle.Transparency = 0.5
        particle.Parent = workspace
        
        TweenService:Create(particle, TweenInfo.new(0.5), {
            Position = position + Vector3.new(0, 3, 0),
            Transparency = 1
        }):Play()
        
        Debris:AddItem(particle, 0.5)
    end
    
    TweenService:Create(portal, TweenInfo.new(0.5), {
        Transparency = 1,
        Size = Vector3.new(10, 0.4, 10)
    }):Play()
    
    TweenService:Create(rim, TweenInfo.new(0.5), {
        Transparency = 1,
        Size = Vector3.new(12, 0.5, 12)
    }):Play()
    
    Debris:AddItem(portal, 0.5)
    Debris:AddItem(rim, 0.5)
end

function EffectsModule.createShadowStepTrail(startPos, endPos)
    local steps = 10
    for i = 1, steps do
        local progress = i / steps
        local pos = startPos:Lerp(endPos, progress)
        
        local trail = Instance.new("Part")
        trail.Size = Vector3.new(1.5, 3, 1.5)
        trail.Position = pos
        trail.Anchored = true
        trail.CanCollide = false
        trail.Material = Enum.Material.Neon
        trail.Color = Color3.fromRGB(138, 43, 226)
        trail.Transparency = 0.3
        trail.Parent = workspace
        
        TweenService:Create(trail, TweenInfo.new(0.4), {
            Transparency = 1,
            Size = Vector3.new(0.5, 1, 0.5)
        }):Play()
        
        Debris:AddItem(trail, 0.4)
    end
end

function EffectsModule.createDashTrail()
    if not rootPart then return end
    
    local trail = Instance.new("Part")
    trail.Size = Vector3.new(2, 2, 2)
    trail.Position = rootPart.Position
    trail.Anchored = true
    trail.CanCollide = false
    trail.Material = Enum.Material.Neon
    trail.Color = Color3.fromRGB(34, 197, 94)
    trail.Transparency = 0.5
    trail.Parent = workspace
    
    TweenService:Create(trail, TweenInfo.new(0.3), {
        Transparency = 1,
        Size = Vector3.new(0.5, 0.5, 0.5)
    }):Play()
    
    Debris:AddItem(trail, 0.3)
end

function EffectsModule.createSecondChanceEffect()
    if not rootPart then return end
    
    -- Purple resurrection aura
    for i = 1, 20 do
        local part = Instance.new("Part")
        part.Size = Vector3.new(0.8, 0.8, 0.8)
        part.Position = rootPart.Position + Vector3.new(
            math.random(-2, 2),
            math.random(0, 3),
            math.random(-2, 2)
        )
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(168, 85, 247)
        part.Transparency = 0.3
        part.Parent = workspace
        
        TweenService:Create(part, TweenInfo.new(1.2), {
            Position = rootPart.Position,
            Transparency = 1,
            Size = Vector3.new(0.2, 0.2, 0.2)
        }):Play()
        
        Debris:AddItem(part, 1.2)
    end
end

function EffectsModule.createSkillLevelUpEffect(skillName)
    if not rootPart then return end
    
    local part = Instance.new("Part")
    part.Size = Vector3.new(1, 1, 1)
    part.Position = rootPart.Position + Vector3.new(0, 5, 0)
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Parent = workspace
    
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Size = UDim2.new(0, 400, 0, 100)
    billboardGui.StudsOffset = Vector3.new(0, 0, 0)
    billboardGui.AlwaysOnTop = true
    billboardGui.Parent = part
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.GothamBold
    label.TextSize = 32
    label.Text = skillName .. " LEVEL UP!"
    label.TextColor3 = Color3.fromRGB(138, 43, 226)
    label.TextStrokeTransparency = 0
    label.Parent = billboardGui
    
    TweenService:Create(billboardGui, TweenInfo.new(2), {StudsOffset = Vector3.new(0, 3, 0)}):Play()
    TweenService:Create(label, TweenInfo.new(2), {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
    
    Debris:AddItem(part, 2)
end

function EffectsModule.createRampageUnlockEffect()
    if not rootPart then return end
    
    local playerGui = player:WaitForChild("PlayerGui")
    local flash = Instance.new("Frame")
    flash.Size = UDim2.new(1, 0, 1, 0)
    flash.BackgroundColor3 = Color3.fromRGB(211, 47, 47)
    flash.BackgroundTransparency = 0
    flash.BorderSizePixel = 0
    flash.ZIndex = 100
    flash.Parent = playerGui
    
    TweenService:Create(flash, TweenInfo.new(1.5), {BackgroundTransparency = 1}):Play()
    Debris:AddItem(flash, 1.5)
    
    EffectsModule.spawnSystemText("RAMPAGE UNLOCKED", Vector3.new(0, 3, 0))
end

function EffectsModule.spawnSystemText(text, offset)
    if not rootPart then return end

    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(1,1,1)
    part.CFrame = rootPart.CFrame * CFrame.new(offset)
    part.Parent = workspace

    local gui = Instance.new("BillboardGui")
    gui.Size = UDim2.new(0, 300, 0, 100)
    gui.AlwaysOnTop = true
    gui.StudsOffset = Vector3.new(0, 0, 0)
    gui.Parent = part

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1,0,1,0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.Font = Enum.Font.GothamBlack
    label.TextScaled = true
    label.TextColor3 = Color3.fromRGB(255, 60, 60)
    label.TextStrokeTransparency = 0
    label.TextStrokeColor3 = Color3.new(0,0,0)
    label.Parent = gui

    TweenService:Create(part, TweenInfo.new(1.5), {
        CFrame = part.CFrame * CFrame.new(0, 5, 0)
    }):Play()

    TweenService:Create(label, TweenInfo.new(1.5), {
        TextTransparency = 1,
        TextStrokeTransparency = 1
    }):Play()

    Debris:AddItem(part, 1.6)
end

function EffectsModule.createAwakeningSequence()
    if not rootPart then return end
    
    -- Intense camera shake
    local camera = workspace.CurrentCamera
    local originalCF = camera.CFrame
    
    task.spawn(function()
        for i = 1, 60 do
            local intensity = i <= 30 and (i / 30) or (60 - i) / 30
            camera.CFrame = originalCF * CFrame.Angles(
                math.rad(math.random(-Config.VFX.CAMERA_SHAKE_INTENSITY, Config.VFX.CAMERA_SHAKE_INTENSITY) * intensity),
                math.rad(math.random(-Config.VFX.CAMERA_SHAKE_INTENSITY, Config.VFX.CAMERA_SHAKE_INTENSITY) * intensity),
                math.rad(math.random(-Config.VFX.CAMERA_SHAKE_INTENSITY, Config.VFX.CAMERA_SHAKE_INTENSITY) * intensity)
            )
            task.wait(0.03)
        end
        camera.CFrame = originalCF
    end)
    
    -- Dense pressure dome
    for i = 1, 5 do
        task.spawn(function()
            local pressureDome = Instance.new("Part")
            pressureDome.Size = Vector3.new(20, 20, 20)
            pressureDome.Position = rootPart.Position
            pressureDome.Anchored = true
            pressureDome.CanCollide = false
            pressureDome.Material = Enum.Material.ForceField
            pressureDome.Color = Color3.fromRGB(75, 0, 130)
            pressureDome.Transparency = 0.8
            pressureDome.Parent = workspace
            
            local mesh = Instance.new("SpecialMesh")
            mesh.MeshType = Enum.MeshType.Sphere
            mesh.Parent = pressureDome
            
            TweenService:Create(pressureDome, TweenInfo.new(0.6), {
                Size = Vector3.new(50, 50, 50),
                Transparency = 1
            }):Play()
            
            Debris:AddItem(pressureDome, 0.6)
            task.wait(0.4)
        end)
    end
    
    -- Ground crack effect
    for i = 1, 12 do
        task.spawn(function()
            local angle = (i / 12) * math.pi * 2
            local crack = Instance.new("Part")
            crack.Size = Vector3.new(1, 0.5, 8)
            crack.Position = rootPart.Position + Vector3.new(
                math.cos(angle) * 4,
                -2,
                math.sin(angle) * 4
            )
            crack.Anchored = true
            crack.CanCollide = false
            crack.Material = Enum.Material.Neon
            crack.Color = Color3.fromRGB(139, 0, 0)
            crack.Transparency = 0.3
            crack.Parent = workspace
            
            TweenService:Create(crack, TweenInfo.new(0.5), {
                Size = Vector3.new(1, 0.5, 15),
                Transparency = 1
            }):Play()
            
            Debris:AddItem(crack, 0.5)
        end)
    end
    
    -- Red energy spiral
    task.spawn(function()
        for i = 1, 30 do
            local height = (i / 30) * 10
            local angle = (i / 30) * math.pi * 6
            
            local energy = Instance.new("Part")
            energy.Size = Vector3.new(1, 1, 1)
            energy.Position = rootPart.Position + Vector3.new(
                math.cos(angle) * 3,
                height,
                math.sin(angle) * 3
            )
            energy.Anchored = true
            energy.CanCollide = false
            energy.Material = Enum.Material.Neon
            energy.Color = Color3.fromRGB(255, 0, 0)
            energy.Transparency = 0.2
            energy.Parent = workspace
            
            TweenService:Create(energy, TweenInfo.new(0.8), {
                Transparency = 1,
                Size = Vector3.new(0.2, 0.2, 0.2)
            }):Play()
            
            Debris:AddItem(energy, 0.8)
            task.wait(0.05)
        end
    end)
    
    -- System messages
    task.wait(0.5)
    EffectsModule.spawnSystemText("AWAKENING", Vector3.new(0, 4, 0))
    task.wait(1)
    EffectsModule.spawnSystemText("RAMPAGE MODE", Vector3.new(0, 4, 0))
end

function EffectsModule.createRampageAura()
    if not rootPart then return end
    
    -- Continuous dark red aura
    local auraConnection
    auraConnection = RunService.Heartbeat:Connect(function()
        if not PlayerData.rampage.isActive or not rootPart then
            auraConnection:Disconnect()
            return
        end
        
        if math.random() > 0.7 then
            local aura = Instance.new("Part")
            aura.Size = Vector3.new(1, 1, 1)
            aura.Position = rootPart.Position + Vector3.new(
                math.random(-3, 3),
                math.random(-1, 3),
                math.random(-3, 3)
            )
            aura.Anchored = true
            aura.CanCollide = false
            aura.Material = Enum.Material.Neon
            aura.Color = Color3.fromRGB(139, 0, 0)
            aura.Transparency = 0.4
            aura.Parent = workspace
            
            TweenService:Create(aura, TweenInfo.new(0.6), {
                Position = aura.Position + Vector3.new(0, 2, 0),
                Transparency = 1,
                Size = Vector3.new(0.2, 0.2, 0.2)
            }):Play()
            
            Debris:AddItem(aura, 0.6)
        end
    end)
end

function EffectsModule.createBehindYouEffect(startPos, targetPos)
    -- Create initial portal
    EffectsModule.createShadowPortal(startPos)
    
    -- Dramatic disappearance
    local fadeClone = character:Clone()
    for _, part in pairs(fadeClone:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Anchored = true
            part.CanCollide = false
            part.Material = Enum.Material.Neon
            part.Color = Color3.fromRGB(138, 43, 226)
            
            TweenService:Create(part, TweenInfo.new(0.3), {
                Transparency = 1
            }):Play()
        end
    end
    fadeClone.Parent = workspace
    Debris:AddItem(fadeClone, 0.3)
    
    -- Shadow trail
    local steps = 15
    for i = 1, steps do
        task.spawn(function()
            local progress = i / steps
            local pos = startPos:Lerp(targetPos, progress)
            
            local shadow = Instance.new("Part")
            shadow.Size = Vector3.new(2, 4, 2)
            shadow.Position = pos
            shadow.Anchored = true
            shadow.CanCollide = false
            shadow.Material = Enum.Material.Neon
            shadow.Color = Color3.fromRGB(75, 0, 130)
            shadow.Transparency = 0.5
            shadow.Parent = workspace
            
            TweenService:Create(shadow, TweenInfo.new(0.5), {
                Transparency = 1,
                Size = Vector3.new(0.5, 1, 0.5)
            }):Play()
            
            Debris:AddItem(shadow, 0.5)
        end)
    end
    
    -- Arrival portal
    task.wait(0.15)
    EffectsModule.createShadowPortal(targetPos)
    
    -- Menacing smoke burst
    for i = 1, Config.VFX.BEHIND_YOU_SMOKE do
        task.spawn(function()
            local smoke = Instance.new("Part")
            smoke.Size = Vector3.new(1, 1, 1)
            smoke.Position = targetPos + Vector3.new(
                math.random(-2, 2),
                math.random(0, 3),
                math.random(-2, 2)
            )
            smoke.Anchored = true
            smoke.CanCollide = false
            smoke.Material = Enum.Material.Neon
            smoke.Color = Color3.fromRGB(75, 0, 130)
            smoke.Transparency = 0.3
            smoke.Parent = workspace
            
            local mesh = Instance.new("SpecialMesh")
            mesh.MeshType = Enum.MeshType.Sphere
            mesh.Parent = smoke
            
            TweenService:Create(smoke, TweenInfo.new(0.6), {
                Position = smoke.Position + Vector3.new(
                    math.random(-4, 4),
                    math.random(2, 5),
                    math.random(-4, 4)
                ),
                Size = Vector3.new(2, 2, 2),
                Transparency = 1
            }):Play()
            
            Debris:AddItem(smoke, 0.6)
        end)
    end
    
    -- Purple shockwave
    local arrivalShock = Instance.new("Part")
    arrivalShock.Size = Vector3.new(2, 0.5, 2)
    arrivalShock.Position = targetPos
    arrivalShock.Anchored = true
    arrivalShock.CanCollide = false
    arrivalShock.Material = Enum.Material.Neon
    arrivalShock.Color = Color3.fromRGB(138, 43, 226)
    arrivalShock.Transparency = 0.3
    arrivalShock.Parent = workspace
    
    local shockMesh = Instance.new("CylinderMesh")
    shockMesh.Parent = arrivalShock
    
    TweenService:Create(arrivalShock, TweenInfo.new(0.5), {
        Size = Vector3.new(15, 0.5, 15),
        Transparency = 1
    }):Play()
    
    Debris:AddItem(arrivalShock, 0.5)
    
    -- Camera distortion
    local camera = workspace.CurrentCamera
    local originalCF = camera.CFrame
    
    task.spawn(function()
        for i = 1, 8 do
            camera.CFrame = originalCF * CFrame.Angles(
                math.rad(math.random(-1, 1)),
                math.rad(math.random(-1, 1)),
                math.rad(math.random(-1, 1))
            )
            task.wait(0.03)
        end
        camera.CFrame = originalCF
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ¨ UI MODULE (WITH TWEENSERVICE FIX)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local UIModule = {}

function UIModule.createRoundedFrame(parent, size, position, bgColor, transparency)
    local frame = Instance.new("Frame")
    frame.Size = size
    frame.Position = position
    frame.BackgroundColor3 = bgColor
    frame.BackgroundTransparency = transparency or 0
    frame.BorderSizePixel = 0
    frame.Parent = parent
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = frame
    
    return frame
end

function UIModule.createTextLabel(parent, text, size, position, textColor, fontSize, font, alignment)
    local label = Instance.new("TextLabel")
    label.Text = text
    label.Size = size
    label.Position = position
    label.TextColor3 = textColor or Color3.fromRGB(255, 255, 255)
    label.Font = font or Enum.Font.GothamBold
    label.TextSize = fontSize or 24
    label.BackgroundTransparency = 1
    label.TextXAlignment = alignment or Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextWrapped = true
    label.Parent = parent
    
    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(0, 0, 0)
    stroke.Transparency = 0.3
    stroke.Parent = label
    
    return label
end

function UIModule.createButton(parent, text, size, position, bgColor, textColor, fontSize, callback)
    local button = Instance.new("TextButton")
    button.Text = text
    button.Size = size
    button.Position = position
    button.BackgroundColor3 = bgColor
    button.TextColor3 = textColor
    button.Font = Enum.Font.GothamBold
    button.TextSize = fontSize
    button.BorderSizePixel = 0
    button.AutoButtonColor = false
    button.Parent = parent
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = button
    
    if callback then
        button.MouseButton1Click:Connect(callback)
    end
    
    button.MouseEnter:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.new(
                math.min(bgColor.R + 0.2, 1),
                math.min(bgColor.G + 0.2, 1),
                math.min(bgColor.B + 0.2, 1)
            )
        }):Play()
    end)
    
    button.MouseLeave:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = bgColor
        }):Play()
    end)
    
    return button
end

function UIModule.updateUI()
    if levelValueLabel then
        levelValueLabel.Text = PlayerData.level .. "/" .. Config.LEVEL_CAP
    end
    
    if xpBar and xpTextLabel then
        local maxXP = LevelSystem.calculateRequiredXP(PlayerData.level)
        local progress = math.clamp(PlayerData.xp / maxXP, 0, 1)
        
        TweenService:Create(xpBar, TweenInfo.new(0.35), {
            Size = UDim2.new(progress, 0, 1, 0)
        }):Play()
        
        xpTextLabel.Text = "EXP: " .. PlayerData.xp .. "/" .. maxXP
    end
    
    if hpBar and hpTextLabel and humanoid then
        -- Always use Humanoid as source of truth
        local hpPercent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
        
        TweenService:Create(hpBar, TweenInfo.new(0.2), {
            Size = UDim2.new(hpPercent, 0, 1, 0)
        }):Play()
        
        hpTextLabel.Text = math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth)
    end
    
    if pointsValueLabel then
        pointsValueLabel.Text = tostring(PlayerData.availablePoints)
    end
    
    local currentRank = LevelSystem.getCurrentRank()
    if rankLabel then
        rankLabel.Text = currentRank.name
        rankLabel.TextColor3 = currentRank.color
    end
    
    if titleLabel then
        titleLabel.Text = currentRank.title:upper()
    end
    
    if classLabel then
        classLabel.Text = LevelSystem.getCurrentClass():upper()
    end
    
    if statusLabel then
        statusLabel.Text = currentRank.status
    end
    
    if ssLevelLabel then
        ssLevelLabel.Text = "LV " .. PlayerData.shadowStep.level
    end
    
    if rampageKillLabel then
        if PlayerData.rampage.cooldown > 0 then
            rampageKillLabel.Text = string.format("KILLS: %d/%d", PlayerData.rampage.currentKills, PlayerData.rampage.killsRequired)
            rampageKillLabel.Visible = true
        else
            rampageKillLabel.Visible = false
        end
    end
end

function UIModule.showStatDescription(statData)
    local playerGui = player:WaitForChild("PlayerGui")
    
    local descGui = Instance.new("ScreenGui")
    descGui.Name = "StatDescription"
    descGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    descGui.Parent = playerGui
    
    local overlay = Instance.new("Frame")
    overlay.Size = UDim2.new(1, 0, 1, 0)
    overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    overlay.BackgroundTransparency = 0.5
    overlay.BorderSizePixel = 0
    overlay.ZIndex = 1000
    overlay.Parent = descGui
    
    local descFrame = UIModule.createRoundedFrame(
        overlay,
        UDim2.new(0, 500, 0, 350),
        UDim2.new(0.5, -250, 0.5, -175),
        Color3.fromRGB(15, 20, 35),
        0
    )
    descFrame.ZIndex = 1001
    
    local frameStroke = Instance.new("UIStroke")
    frameStroke.Color = statData.color
    frameStroke.Thickness = 4
    frameStroke.Parent = descFrame
    
    local titleBar = UIModule.createRoundedFrame(
        descFrame,
        UDim2.new(1, 0, 0, 60),
        UDim2.new(0, 0, 0, 0),
        statData.color,
        0
    )
    titleBar.ZIndex = 1002
    
    local titleLabel = UIModule.createTextLabel(
        titleBar,
        statData.title,
        UDim2.new(1, -20, 1, 0),
        UDim2.new(0, 10, 0, 0),
        Color3.fromRGB(255, 255, 255),
        28,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Center
    )
    titleLabel.ZIndex = 1003
    
    local descText = UIModule.createTextLabel(
        descFrame,
        statData.description,
        UDim2.new(1, -40, 0, 220),
        UDim2.new(0, 20, 0, 75),
        Color3.fromRGB(220, 220, 220),
        20,
        Enum.Font.Gotham,
        Enum.TextXAlignment.Left
    )
    descText.TextYAlignment = Enum.TextYAlignment.Top
    descText.ZIndex = 1003
    
    local closeButton = UIModule.createButton(
        descFrame,
        "CLOSE",
        UDim2.new(0, 200, 0, 45),
        UDim2.new(0.5, -100, 1, -60),
        Color3.fromRGB(51, 65, 85),
        Color3.fromRGB(255, 255, 255),
        20,
        function()
            descGui:Destroy()
        end
    )
    closeButton.ZIndex = 1003
    
    overlay.MouseButton1Click:Connect(function()
        descGui:Destroy()
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ® MAIN UI CREATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function UIModule.createMainUI()
    local hrp = character:WaitForChild("HumanoidRootPart")
    
    mainPart = Instance.new("Part")
    mainPart.Name = "StatSystemObject"
    mainPart.Size = Vector3.new(14, 8, 0.2)
    mainPart.CFrame = hrp.CFrame * CFrame.new(0, 2, -10)
    mainPart.Anchored = true
    mainPart.CanCollide = false
    mainPart.Transparency = 0.05
    mainPart.Material = Enum.Material.ForceField
    mainPart.Parent = workspace
    
    local surfaceGui = Instance.new("SurfaceGui")
    surfaceGui.Face = Enum.NormalId.Front
    surfaceGui.CanvasSize = Vector2.new(1400, 800)
    surfaceGui.LightInfluence = 0
    surfaceGui.Brightness = 2
    surfaceGui.Enabled = false
    surfaceGui.AlwaysOnTop = true
    surfaceGui.Parent = mainPart
    
    -- Control Buttons
    local playerGui = player:WaitForChild("PlayerGui")
    local toggleGui = Instance.new("ScreenGui")
    toggleGui.Name = "StatToggleGui"
    toggleGui.ResetOnSpawn = false
    toggleGui.Parent = playerGui
    
    local buttonContainer = Instance.new("Frame")
    buttonContainer.Size = UDim2.new(0, 65, 0, 225)
    buttonContainer.Position = UDim2.new(0, 20, 0.5, -112)
    buttonContainer.BackgroundTransparency = 1
    buttonContainer.Parent = toggleGui
    
    -- Stats Button
    statsButton = UIModule.createButton(
        buttonContainer,
        "STATS",
        UDim2.new(0, 60, 0, 60),
        UDim2.new(0, 2, 0, 0),
        Color3.fromRGB(8, 145, 178),
        Color3.fromRGB(255, 255, 255),
        20,
        function()
            isVisible = not isVisible
            surfaceGui.Enabled = isVisible
            if isVisible then
                local mainFrame = surfaceGui:FindFirstChild("MainFrame")
                if mainFrame then
                    mainFrame.Size = UDim2.new(1, 0, 0, 0)
                    TweenService:Create(mainFrame, TweenInfo.new(0.5), {
                        Size = UDim2.new(1, 0, 1, 0)
                    }):Play()
                end
            end
        end
    )
    
    local statsCorner = Instance.new("UICorner")
    statsCorner.CornerRadius = UDim.new(0, 10)
    statsCorner.Parent = statsButton
    
    -- Shadow Step Button
    shadowStepButton = UIModule.createButton(
        buttonContainer,
        "DASH",
        UDim2.new(0, 60, 0, 60),
        UDim2.new(0, 2, 0, 72),
        Color3.fromRGB(51, 51, 51),
        Color3.fromRGB(150, 150, 150),
        16,
        AbilityModule.performShadowStep
    )
    shadowStepButton.Visible = PlayerData.shadowStep.unlocked
    
    local shadowCorner = Instance.new("UICorner")
    shadowCorner.CornerRadius = UDim.new(0, 10)
    shadowCorner.Parent = shadowStepButton
    
    ssLevelLabel = UIModule.createTextLabel(
        shadowStepButton,
        "LV " .. PlayerData.shadowStep.level,
        UDim2.new(1, 0, 0, 18),
        UDim2.new(0, 0, 1, -20),
        Color3.fromRGB(138, 43, 226),
        11
    )
    ssLevelLabel.TextXAlignment = Enum.TextXAlignment.Center
    
    cooldownBar = Instance.new("Frame")
    cooldownBar.Size = UDim2.new(1, 0, 0, 4)
    cooldownBar.Position = UDim2.new(0, 0, 1, -4)
    cooldownBar.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
    cooldownBar.BorderSizePixel = 0
    cooldownBar.Parent = shadowStepButton
    
    -- Rampage Button
    rampageButton = UIModule.createButton(
        buttonContainer,
        "RAGE",
        UDim2.new(0, 60, 0, 60),
        UDim2.new(0, 2, 0, 144),
        Color3.fromRGB(139, 0, 0),
        Color3.fromRGB(255, 255, 255),
        18,
        AbilityModule.activateRampage
    )
    rampageButton.Visible = PlayerData.rampage.unlocked
    
    local rampageCorner = Instance.new("UICorner")
    rampageCorner.CornerRadius = UDim.new(0, 10)
    rampageCorner.Parent = rampageButton
    
    -- Rampage Kill Counter Label
    rampageKillLabel = UIModule.createTextLabel(
        rampageButton,
        string.format("%d/%d", PlayerData.rampage.currentKills, PlayerData.rampage.killsRequired),
        UDim2.new(1, 0, 0, 16),
        UDim2.new(0, 0, 1, -18),
        Color3.fromRGB(255, 215, 0),
        10
    )
    rampageKillLabel.TextXAlignment = Enum.TextXAlignment.Center
    rampageKillLabel.TextScaled = true
    rampageKillLabel.Visible = false
    
    -- Behind You Button (hidden until Rampage)
    behindYouButton = UIModule.createButton(
        buttonContainer,
        "BEHIND\nYOU",
        UDim2.new(0, 60, 0, 60),
        UDim2.new(1, -65, 0, 144),
        Color3.fromRGB(75, 0, 130),
        Color3.fromRGB(255, 255, 255),
        14,
        AbilityModule.performBehindYou
    )
    behindYouButton.Visible = false
    
    local behindCorner = Instance.new("UICorner")
    behindCorner.CornerRadius = UDim.new(0, 10)
    behindCorner.Parent = behindYouButton
    
    -- Main Frame
    local mainFrame = UIModule.createRoundedFrame(
        surfaceGui,
        UDim2.new(1, 0, 0, 0),
        UDim2.new(0, 0, 0, 0),
        Color3.fromRGB(10, 15, 30),
        0
    )
    mainFrame.Name = "MainFrame"
    
    local mainStroke = Instance.new("UIStroke")
    mainStroke.Color = Color3.fromRGB(6, 182, 212)
    mainStroke.Thickness = 10
    mainStroke.Parent = mainFrame
    
    -- Title Section
    local titleSection = UIModule.createRoundedFrame(
        mainFrame,
        UDim2.new(1, 0, 0, 80),
        UDim2.new(0, 0, 0, 0),
        Color3.fromRGB(15, 20, 35),
        0
    )
    
    UIModule.createTextLabel(
        titleSection,
        "SYSTEM",
        UDim2.new(1, -40, 1, 0),
        UDim2.new(0, 20, 0, 0),
        Color3.fromRGB(6, 182, 212),
        42,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Center
    )
    
    -- HP Section
    local hpSection = Instance.new("Frame")
    hpSection.Size = UDim2.new(1, -60, 0, 60)
    hpSection.Position = UDim2.new(0, 30, 0, 95)
    hpSection.BackgroundTransparency = 1
    hpSection.Parent = mainFrame
    
    UIModule.createTextLabel(
        hpSection,
        "HP",
        UDim2.new(0, 60, 0, 32),
        UDim2.new(0, 0, 0, 14),
        Color3.fromRGB(239, 68, 68),
        28
    )
    
    local hpBarBg = UIModule.createRoundedFrame(
        hpSection,
        UDim2.new(0, 900, 0, 32),
        UDim2.new(0, 70, 0, 14),
        Color3.fromRGB(20, 25, 40),
        0
    )
    
    local hpBorder = Instance.new("UIStroke")
    hpBorder.Color = Color3.fromRGB(239, 68, 68)
    hpBorder.Thickness = 3
    hpBorder.Parent = hpBarBg
    
    hpBar = UIModule.createRoundedFrame(
        hpBarBg,
        UDim2.new(1, 0, 1, 0),
        UDim2.new(0, 0, 0, 0),
        Color3.fromRGB(220, 38, 38),
        0
    )
    
    hpTextLabel = UIModule.createTextLabel(
        hpBar,
        math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth),
        UDim2.new(1, -15, 1, 0),
        UDim2.new(0, 0, 0, 0),
        Color3.fromRGB(255, 255, 255),
        22,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Right
    )
    
    UIModule.createTextLabel(
        hpSection,
        "LV",
        UDim2.new(0, 50, 0, 32),
        UDim2.new(1, -180, 0, 14),
        Color3.fromRGB(150, 150, 150),
        24
    )
    
    levelValueLabel = UIModule.createTextLabel(
        hpSection,
        PlayerData.level .. "/" .. Config.LEVEL_CAP,
        UDim2.new(0, 125, 0, 32),
        UDim2.new(1, -125, 0, 14),
        Color3.fromRGB(255, 255, 255),
        24
    )
    
    -- XP Bar
    local xpBarBg = UIModule.createRoundedFrame(
        mainFrame,
        UDim2.new(1, -60, 0, 22),
        UDim2.new(0, 30, 0, 167),
        Color3.fromRGB(20, 25, 40),
        0
    )
    
    local xpBorder = Instance.new("UIStroke")
    xpBorder.Color = Color3.fromRGB(34, 211, 238)
    xpBorder.Thickness = 3
    xpBorder.Parent = xpBarBg
    
    xpBar = UIModule.createRoundedFrame(
        xpBarBg,
        UDim2.new(PlayerData.xp / LevelSystem.calculateRequiredXP(PlayerData.level), 0, 1, 0),
        UDim2.new(0, 0, 0, 0),
        Color3.fromRGB(34, 211, 238),
        0
    )
    
    xpTextLabel = UIModule.createTextLabel(
        xpBarBg,
        "EXP: " .. PlayerData.xp .. "/" .. LevelSystem.calculateRequiredXP(PlayerData.level),
        UDim2.new(1, -12, 1, 0),
        UDim2.new(0, 12, 0, 0),
        Color3.fromRGB(255, 255, 255),
        18,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Left
    )
    
    -- Stats Container
    local statsContainer = Instance.new("Frame")
    statsContainer.Size = UDim2.new(1, -60, 0, 320)
    statsContainer.Position = UDim2.new(0, 30, 0, 205)
    statsContainer.BackgroundTransparency = 1
    statsContainer.Parent = mainFrame
    
    local function createStatRow(statKey, yPos, xPos)
        local stat = StatInfo[statKey]
        local statFrame = UIModule.createRoundedFrame(
            statsContainer,
            UDim2.new(0, 650, 0, 85),
            UDim2.new(0, xPos, 0, yPos),
            Color3.fromRGB(20, 25, 40),
            0
        )
        
        local statBorder = Instance.new("UIStroke")
        statBorder.Color = stat.color
        statBorder.Thickness = 3
        statBorder.Parent = statFrame
        
        local abbrBox = UIModule.createRoundedFrame(
            statFrame,
            UDim2.new(0, 90, 0, 55),
            UDim2.new(0, 15, 0, 15),
            Color3.fromRGB(15, 20, 35),
            0
        )
        
        local abbrBorder = Instance.new("UIStroke")
        abbrBorder.Color = stat.color
        abbrBorder.Thickness = 3
        abbrBorder.Parent = abbrBox
        
        UIModule.createTextLabel(
            abbrBox,
            stat.abbr,
            UDim2.new(1, 0, 1, 0),
            UDim2.new(0, 0, 0, 0),
            stat.color,
            26,
            Enum.Font.GothamBold,
            Enum.TextXAlignment.Center
        )
        
        UIModule.createTextLabel(
            statFrame,
            stat.name,
            UDim2.new(0, 180, 0, 40),
            UDim2.new(0, 115, 0, 22),
            Color3.fromRGB(220, 220, 220),
            24
        )
        
        local valueLabel = UIModule.createTextLabel(
            statFrame,
            tostring(PlayerData.stats[statKey]),
            UDim2.new(0, 65, 0, 40),
            UDim2.new(0, 300, 0, 22),
            Color3.fromRGB(255, 255, 255),
            32,
            Enum.Font.GothamBold,
            Enum.TextXAlignment.Center
        )
        
        local effectLabel = UIModule.createTextLabel(
            statFrame,
            stat.getEffect(PlayerData.stats[statKey]),
            UDim2.new(0, 160, 0, 26),
            UDim2.new(0, 375, 0, 29),
            stat.color,
            18,
            Enum.Font.Gotham,
            Enum.TextXAlignment.Left
        )
        
        UIModule.createButton(
            statFrame,
            "?",
            UDim2.new(0, 35, 0, 35),
            UDim2.new(0, 540, 0, 25),
            Color3.fromRGB(30, 35, 50),
            Color3.fromRGB(200, 200, 200),
            22,
            function()
                UIModule.showStatDescription(stat)
            end
        )
        
        UIModule.createButton(
            statFrame,
            "+",
            UDim2.new(0, 45, 0, 45),
            UDim2.new(0, 585, 0, 20),
            Color3.fromRGB(51, 65, 85),
            stat.color,
            30,
            function()
                if PlayerData.availablePoints > 0 and PlayerData.stats[statKey] < Config.MAX_STAT_VALUE then
                    PlayerData.stats[statKey] = math.min(PlayerData.stats[statKey] + 1, Config.MAX_STAT_VALUE)
                    PlayerData.availablePoints = PlayerData.availablePoints - 1
                    
                    StatCalculator.applyStatEffects()
                    task.spawn(function()
                        EffectsModule.createStatUpgradeEffect(statKey)
                    end)
                    
                    valueLabel.Text = tostring(PlayerData.stats[statKey])
                    effectLabel.Text = stat.getEffect(PlayerData.stats[statKey])
                    
                    UIModule.updateUI()
                end
            end
        )
    end
    
    createStatRow("strength", 0, 0)
    createStatRow("agility", 95, 0)
    createStatRow("perception", 190, 0)
    createStatRow("vitality", 0, 700)
    createStatRow("intelligence", 95, 700)
    
    -- Available Points
    local pointsBox = UIModule.createRoundedFrame(
        statsContainer,
        UDim2.new(0, 650, 0, 75),
        UDim2.new(0, 700, 0, 200),
        Color3.fromRGB(20, 30, 50),
        0
    )
    
    local pointsStroke = Instance.new("UIStroke")
    pointsStroke.Color = Color3.fromRGB(34, 211, 238)
    pointsStroke.Thickness = 5
    pointsStroke.Parent = pointsBox
    
    UIModule.createTextLabel(
        pointsBox,
        "Available Points",
        UDim2.new(0, 380, 1, 0),
        UDim2.new(0, 30, 0, 0),
        Color3.fromRGB(220, 220, 220),
        26
    )
    
    pointsValueLabel = UIModule.createTextLabel(
        pointsBox,
        tostring(PlayerData.availablePoints),
        UDim2.new(0, 220, 1, 0),
        UDim2.new(1, -240, 0, 0),
        Color3.fromRGB(34, 211, 238),
        38,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Center
    )
    
    -- Info Container
    local infoContainer = Instance.new("Frame")
    infoContainer.Size = UDim2.new(1, -60, 0, 160)
    infoContainer.Position = UDim2.new(0, 30, 0, 540)
    infoContainer.BackgroundTransparency = 1
    infoContainer.Parent = mainFrame
    
    local function createInfoRow(label, value, xPos, yPos, valueColor)
        UIModule.createTextLabel(
            infoContainer,
            label,
            UDim2.new(0, 160, 0, 50),
            UDim2.new(0, xPos, 0, yPos),
            Color3.fromRGB(160, 160, 160),
            24
        )
        
        local valueText = UIModule.createTextLabel(
            infoContainer,
            value,
            UDim2.new(0, 470, 0, 50),
            UDim2.new(0, xPos + 165, 0, yPos),
            valueColor,
            26,
            Enum.Font.GothamBold,
            Enum.TextXAlignment.Right
        )
        valueText.TextScaled = true
        return valueText
    end
    
    local currentRank = LevelSystem.getCurrentRank()
    rankLabel = createInfoRow("RANK", currentRank.name, 0, 10, currentRank.color)
    classLabel = createInfoRow("CLASS", LevelSystem.getCurrentClass():upper(), 0, 58, Color3.fromRGB(168, 85, 247))
    titleLabel = createInfoRow("TITLE", currentRank.title:upper(), 680, 10, Color3.fromRGB(248, 113, 113))
    statusLabel = createInfoRow("STATUS", currentRank.status, 680, 58, Color3.fromRGB(34, 211, 238))
    
    -- Levitation Effect
    task.spawn(function()
        local t = 0
        while mainPart and mainPart.Parent do
            t = t + task.wait()
            local bobY = math.sin(t * 1.8) * 0.35
            
            if character and character:FindFirstChild("HumanoidRootPart") then
                local hrp = character.HumanoidRootPart
                local charLook = hrp.CFrame.LookVector
                local targetPos = hrp.Position + (charLook * -10) + Vector3.new(0, 2 + bobY, 0)
                
                if isVisible then
                    local lookAtPos = Vector3.new(hrp.Position.X, mainPart.Position.Y, hrp.Position.Z)
                    mainPart.CFrame = mainPart.CFrame:Lerp(CFrame.new(targetPos, lookAtPos), 0.1)
                end
            end
        end
    end)
    
    UIModule.updateUI()
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“¢ INITIAL NOTIFICATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function UIModule.createInitialNotification()
    notifPart = Instance.new("Part")
    notifPart.Name = "NotificationPart"
    notifPart.Size = Vector3.new(12, 7, 0.2)
    notifPart.CFrame = rootPart.CFrame * CFrame.new(0, 3, -8)
    notifPart.Anchored = true
    notifPart.CanCollide = false
    notifPart.Transparency = 0.05
    notifPart.Material = Enum.Material.ForceField
    notifPart.Parent = workspace
    
    local surfaceGui = Instance.new("SurfaceGui")
    surfaceGui.Face = Enum.NormalId.Front
    surfaceGui.CanvasSize = Vector2.new(1200, 700)
    surfaceGui.LightInfluence = 0
    surfaceGui.Brightness = 2
    surfaceGui.AlwaysOnTop = true
    surfaceGui.Parent = notifPart
    
    local bg = UIModule.createRoundedFrame(
        surfaceGui,
        UDim2.new(1, 0, 1, 0),
        UDim2.new(0, 0, 0, 0),
        Color3.fromRGB(10, 15, 30),
        0
    )
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(6, 182, 212)
    stroke.Thickness = 10
    stroke.Parent = bg
    
    UIModule.createTextLabel(
        bg,
        "SYSTEM NOTIFICATION",
        UDim2.new(1, -40, 0, 90),
        UDim2.new(0, 20, 0, 35),
        Color3.fromRGB(6, 182, 212),
        44,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Center
    )
    
    UIModule.createTextLabel(
        bg,
        "You have acquired the qualifications\nto become a Player.\n\nThe System has recognized your potential.\nWill you accept this power?",
        UDim2.new(1, -80, 0, 180),
        UDim2.new(0, 40, 0, 145),
        Color3.fromRGB(220, 220, 220),
        26,
        Enum.Font.Gotham,
        Enum.TextXAlignment.Center
    )
    
    UIModule.createButton(
        bg,
        "ACCEPT",
        UDim2.new(0, 380, 0, 90),
        UDim2.new(0, 80, 1, -130),
        Color3.fromRGB(8, 145, 178),
        Color3.fromRGB(255, 255, 255),
        32,
        function()
            acceptedNotification = true
            TweenService:Create(notifPart, TweenInfo.new(0.3), {Transparency = 1}):Play()
            task.wait(0.3)
            notifPart:Destroy()
            UIModule.createMainUI()
        end
    )
    
    UIModule.createButton(
        bg,
        "DECLINE",
        UDim2.new(0, 380, 0, 90),
        UDim2.new(1, -460, 1, -130),
        Color3.fromRGB(51, 65, 85),
        Color3.fromRGB(255, 255, 255),
        32,
        function()
            acceptedNotification = false
            TweenService:Create(notifPart, TweenInfo.new(0.3), {Transparency = 1}):Play()
            task.wait(0.3)
            notifPart:Destroy()
        end
    )
    
    -- Levitation Effect
    task.spawn(function()
        local t = 0
        while notifPart and notifPart.Parent do
            t = t + task.wait()
            local bobY = math.sin(t * 2) * 0.3
            
            if character and character:FindFirstChild("HumanoidRootPart") then
                local hrp = character.HumanoidRootPart
                local charLook = hrp.CFrame.LookVector
                local targetPos = hrp.Position + (charLook * -8) + Vector3.new(0, 3 + bobY, 0)
                local lookAtPos = Vector3.new(hrp.Position.X, notifPart.Position.Y, hrp.Position.Z)
                notifPart.CFrame = notifPart.CFrame:Lerp(CFrame.new(targetPos, lookAtPos), 0.1)
            end
        end
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ‘¥ PLAYER MONITORING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function monitorPlayers()
    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherHumanoid = otherPlayer.Character:FindFirstChild("Humanoid")
            
            if otherHumanoid and not otherHumanoid:GetAttribute("Monitored") then
                otherHumanoid:SetAttribute("Monitored", true)
                
                otherHumanoid.Died:Connect(function()
                    CombatModule.onPlayerKilled(otherPlayer)
                end)
                
                otherHumanoid.HealthChanged:Connect(function(health)
                    if health < otherHumanoid.MaxHealth and rootPart and otherPlayer.Character then
                        local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
                        
                        if otherRoot then
                            local distance = (rootPart.Position - otherRoot.Position).Magnitude
                            
                            if distance <= 35 then
                                CombatModule.trackCombatEngagement(otherPlayer)
                            elseif distance <= Config.ASSIST_RANGE then
                                for _, p in pairs(Players:GetPlayers()) do
                                    if p ~= player and p ~= otherPlayer and p.Character then
                                        local pRoot = p.Character:FindFirstChild("HumanoidRootPart")
                                        if pRoot and (pRoot.Position - otherRoot.Position).Magnitude <= 35 then
                                            CombatModule.trackAssistEngagement(otherPlayer, p)
                                            if PlayerData.assistEngagement[otherPlayer.UserId] then
                                                PlayerData.assistEngagement[otherPlayer.UserId].playerContributed = true
                                            end
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end)
            end
        end
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ”„ UPDATE LOOPS (OPTIMIZED WITH HEARTBEAT)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function startUpdateLoops()
    -- UI Update Loop using Heartbeat for smoother updates
    RunService.Heartbeat:Connect(function()
        if acceptedNotification then
            UIModule.updateUI()
        end
    end)
    
    -- Cooldown Update Loop
    task.spawn(function()
        while task.wait(0.1) do
            -- Shadow Step cooldown
            if PlayerData.shadowStep.cooldown > 0 then
                PlayerData.shadowStep.cooldown = math.max(0, PlayerData.shadowStep.cooldown - 0.1)
            end
            
            -- Rampage cooldown
            if PlayerData.rampage.cooldown > 0 then
                PlayerData.rampage.cooldown = math.max(0, PlayerData.rampage.cooldown - 0.1)
            end
            
            -- Behind You cooldown
            if PlayerData.behindYou.cooldown > 0 then
                PlayerData.behindYou.cooldown = math.max(0, PlayerData.behindYou.cooldown - 0.1)
            end
            
            -- Shadow Step button visual
            if shadowStepButton and PlayerData.shadowStep.unlocked then
                shadowStepButton.Visible = true
                
                if PlayerData.shadowStep.cooldown > 0 then
                    shadowStepButton.BackgroundColor3 = Color3.fromRGB(51, 51, 51)
                    shadowStepButton.TextColor3 = Color3.fromRGB(150, 150, 150)
                else
                    shadowStepButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
                    shadowStepButton.TextColor3 = Color3.fromRGB(138, 43, 226)
                end
                
                if cooldownBar then
                    local progress = PlayerData.shadowStep.cooldown > 0 and 
                                   (1 - (PlayerData.shadowStep.cooldown / shadowStepMaxCooldown)) or 1
                    cooldownBar.Size = UDim2.new(progress, 0, 0, 4)
                end
            end
            
            -- Rampage button visual
            if rampageButton and PlayerData.rampage.unlocked then
                rampageButton.Visible = true
                
                if PlayerData.rampage.cooldown > 0 or PlayerData.rampage.isActive then
                    rampageButton.BackgroundColor3 = Color3.fromRGB(70, 0, 0)
                    rampageButton.TextColor3 = Color3.fromRGB(150, 150, 150)
                    
                    if PlayerData.rampage.cooldown > 0 then
                        rampageButton.Text = string.format("%.0fs", PlayerData.rampage.cooldown)
                    else
                        rampageButton.Text = "ACTIVE"
                    end
                else
                    rampageButton.BackgroundColor3 = Color3.fromRGB(139, 0, 0)
                    rampageButton.TextColor3 = Color3.fromRGB(255, 255, 255)
                    rampageButton.Text = "RAGE"
                end
            end
            
            -- Behind You button visual
            if behindYouButton and PlayerData.rampage.isActive then
                if PlayerData.behindYou.cooldown > 0 then
                    behindYouButton.BackgroundColor3 = Color3.fromRGB(40, 0, 65)
                    behindYouButton.TextColor3 = Color3.fromRGB(150, 150, 150)
                else
                    behindYouButton.BackgroundColor3 = Color3.fromRGB(75, 0, 130)
                    behindYouButton.TextColor3 = Color3.fromRGB(255, 255, 255)
                end
            end
        end
    end)
    
    -- Player Monitoring Loop
    task.spawn(function()
        while task.wait(2) do
            monitorPlayers()
        end
    end)
    
    -- Combat Engagement Cleanup Loop
    task.spawn(function()
        while task.wait(5) do
            local currentTime = tick()
            
            for userId, engagement in pairs(PlayerData.combatEngagement) do
                if currentTime - engagement.lastHit > Config.COMBAT_TIMEOUT then
                    PlayerData.combatEngagement[userId] = nil
                end
            end
            
            for userId, assist in pairs(PlayerData.assistEngagement) do
                if currentTime - assist.lastHit > Config.ASSIST_TIME_WINDOW then
                    PlayerData.assistEngagement[userId] = nil
                end
            end
        end
    end)
    
    -- Health Regeneration Loop
    task.spawn(function()
        while task.wait(1) do
            if humanoid and humanoid.Health > 0 and humanoid.Health < humanoid.MaxHealth then
                local regenAmount = PlayerData.stats.vitality * Config.STAT_CURVES.vitality.regenPerPoint
                if regenAmount > 0 then
                    humanoid.Health = math.min(humanoid.Health + regenAmount, humanoid.MaxHealth)
                end
            end
        end
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ’€ SECOND CHANCE SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function setupSecondChance()
    if not humanoid then return end
    
    humanoid.Died:Connect(function()
        if PlayerData.hasSecondChance and 
           PlayerData.stats.vitality >= Config.STAT_CURVES.vitality.secondChanceThreshold then
            
            task.wait(0.1)
            
            if humanoid and humanoid.Health <= 0 then
                humanoid.Health = PlayerData.maxHP * 0.5
                PlayerData.hasSecondChance = false
                
                task.spawn(function()
                    EffectsModule.createSecondChanceEffect()
                    EffectsModule.spawnSystemText("SECOND CHANCE ACTIVATED", Vector3.new(0, 3, 0))
                end)
                
                -- Cooldown for Second Chance
                task.wait(60)
                PlayerData.hasSecondChance = true
                
                if PlayerData.stats.vitality >= Config.STAT_CURVES.vitality.secondChanceThreshold then
                    task.spawn(function()
                        EffectsModule.spawnSystemText("SECOND CHANCE READY", Vector3.new(0, 3, 0))
                    end)
                end
            end
        end
    end)
    
    -- Auto-update UI on health changes
    humanoid.HealthChanged:Connect(function()
        UIModule.updateUI()
    end)
    
    humanoid:GetPropertyChangedSignal("MaxHealth"):Connect(function()
        UIModule.updateUI()
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ¯ INPUT HANDLING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function setupInputHandling()
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        -- E key for Shadow Step
        if input.KeyCode == Enum.KeyCode.E then
            AbilityModule.performShadowStep()
        end
        
        -- Shift for Dash
        if input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.RightShift then
            AbilityModule.performDash()
        end
        
        -- R key for Rampage
        if input.KeyCode == Enum.KeyCode.R then
            AbilityModule.activateRampage()
        end
        
        -- F key for Behind You
        if input.KeyCode == Enum.KeyCode.F then
            AbilityModule.performBehindYou()
        end
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ” CHARACTER RESPAWN HANDLER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = newCharacter:WaitForChild("Humanoid")
    rootPart = newCharacter:WaitForChild("HumanoidRootPart")
    
    -- Restore HP with percentage preservation
    humanoid.MaxHealth = PlayerData.maxHP
    humanoid.Health = PlayerData.maxHP
    
    -- Reset Second Chance
    if PlayerData.stats.vitality >= Config.STAT_CURVES.vitality.secondChanceThreshold then
        PlayerData.hasSecondChance = true
    end
    
    task.wait(0.2)
    StatCalculator.applyStatEffects()
    UIModule.updateUI()
    
    -- Reposition UI
    if acceptedNotification and mainPart then
        task.wait(0.5)
        mainPart.CFrame = rootPart.CFrame * CFrame.new(0, 2, -10)
    end
    
    -- Setup Second Chance for new character
    setupSecondChance()
end)

-- Monitor new players joining
Players.PlayerAdded:Connect(function()
    task.wait(1)
    monitorPlayers()
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸš€ INITIALIZATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function initialize()
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("âš¡ SOLO LEVELING SYSTEM - ULTIMATE PERFECTED EDITION V2 âš¡")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("ğŸ“Š INITIAL STATS:")
    print("  STR:", PlayerData.stats.strength, "| AGI:", PlayerData.stats.agility)
    print("  PER:", PlayerData.stats.perception, "| VIT:", PlayerData.stats.vitality)
    print("  INT:", PlayerData.stats.intelligence)
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("ğŸ’ Available Points:", PlayerData.availablePoints)
    print("ğŸ“ˆ Level:", PlayerData.level, "/", Config.LEVEL_CAP)
    print("ğŸ† Class:", LevelSystem.getCurrentClass())
    print("ğŸ–ï¸ Rank:", LevelSystem.getCurrentRank().name)
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("âœ¨ STAT EFFECTS:")
    print("  STR: +2% damage (diminishing after 50)")
    print("  VIT: +20 HP, +0.5 HP/s regen, Second Chance (10+ VIT)")
    print("  AGI: Walk speed scales to 100 cap, +4% dash speed")
    print("  INT: +50 XP per kill, -1% cooldown")
    print("  PER: +10 range, +5% dash range, -2% cooldown")
    print("       +2.1s Rampage duration (max 5min)")
    print("       -15% Behind You cooldown per point")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("ğŸ†• FEATURES:")
    print("  âœ“ Rampage Mode (Level 25+) - All stats MAX")
    print("  âœ“ Rampage Cooldown - Requires 5 kills to reset")
    print("  âœ“ Behind You (Rampage only) - Teleport behind enemies")
    print("  âœ“ Behind You Cooldown - Scales with PER (20s -> 5s)")
    print("  âœ“ Assist XP System (30% XP for assists)")
    print("  âœ“ Second Chance (VIT â‰¥ 10, revive at 50% HP)")
    print("  âœ“ Passive HP Regeneration (VIT)")
    print("  âœ“ Diminishing Returns (STR)")
    print("  âœ“ Awakening Animations & VFX")
    print("  âœ“ Optimized VFX with threading")
    print("  âœ“ HP Bar percentage preservation")
    print("  âœ“ Stat caps at 100 per stat")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("ğŸ® CONTROLS:")
    print("  â€¢ Click STATS button to open panel")
    print("  â€¢ E or DASH button - Shadow Step (Lv 10+)")
    print("  â€¢ SHIFT - Enhanced Dash")
    print("  â€¢ R or RAGE button - Rampage (Lv 25+)")
    print("  â€¢ F or BEHIND YOU button - Behind You (Rampage only)")
    print("  â€¢ Click + to upgrade stats (max 100 per stat)")
    print("  â€¢ Click ? for stat descriptions")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("âš¡ NEW MECHANICS:")
    print("  â€¢ Rampage duration: 1.5min base -> 5min max (PER)")
    print("  â€¢ Rampage cooldown reset: Get 5 kills")
    print("  â€¢ Behind You cooldown: 20s -> 5s (PER)")
    print("  â€¢ All stats start at 0 with 5 points")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("ğŸŒŸ System Status: INITIALIZING...")
    
    -- Apply initial effects
    StatCalculator.applyStatEffects()
    
    if humanoid then
        humanoid.MaxHealth = PlayerData.maxHP
        humanoid.Health = PlayerData.maxHP
    end
    
    -- Setup systems
    setupInputHandling()
    setupSecondChance()
    startUpdateLoops()
    
    -- Initial player monitoring
    monitorPlayers()
    
    -- Show notification after brief delay
    task.wait(1)
    UIModule.createInitialNotification()
    
    print("âœ… System Status: ACTIVE")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

-- Start the system
initialize()
