-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âš¡ SOLO LEVELING SYSTEM - ULTIMATE COMPLETE VERSION
-- Production Ready | All Systems Operational
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ”’ GLOBAL INPUT AUTHORITY
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local InputAuthority = {
    systemBusy = false,
    abilityActive = false,
    uiAnimating = false
}

function InputAuthority:canUseAbility()
    return not (self.systemBusy or self.abilityActive or self.uiAnimating)
end

function InputAuthority:canInteractUI()
    return not (self.systemBusy or self.uiAnimating)
end

function InputAuthority:lockAbilities(duration)
    self.abilityActive = true
    if duration then
        task.delay(duration, function()
            self.abilityActive = false
        end)
    end
end

function InputAuthority:lockUI(duration)
    self.uiAnimating = true
    task.delay(duration, function()
        self.uiAnimating = false
    end)
end

function InputAuthority:lockSystem(duration)
    self.systemBusy = true
    task.delay(duration, function()
        self.systemBusy = false
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ® CORE CONFIGURATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Config = {
    BASE_WALK_SPEED = 16,
    MAX_WALK_SPEED = 100,
    BASE_DASH_SPEED = 50,
    BASE_DASH_RANGE = 30,
    BASE_SHADOW_STEP_RANGE = 50,
    BASE_SHADOW_STEP_COOLDOWN = 10,
    LEVEL_CAP = 100,
    MAX_STAT_VALUE = 100,
    POINTS_PER_LEVEL = 3,
    SHADOW_STEP_UNLOCK_LEVEL = 10,
    RAMPAGE_UNLOCK_LEVEL = 25,
    COMBAT_TIMEOUT = 5,
    MIN_DAMAGE_FOR_CREDIT = 50,
    ASSIST_RANGE = 50,
    ASSIST_TIME_WINDOW = 10,
    BASE_KILL_XP = 200,
    ASSIST_XP_MULTIPLIER = 0.3,
    BEHIND_YOU_MIN_RANGE = 100,
    BEHIND_YOU_MAX_RANGE = 500,
    VFX = {
        SHADOW_PORTAL_PARTICLES = 15,
        LEVEL_UP_PARTICLES = 40,
        STAT_UPGRADE_ORBS = 8,
        RAMPAGE_AURA_DENSITY = 25,
        BEHIND_YOU_SMOKE = 15
    },
    STAT_CURVES = {
        strength = {damagePerPoint = 2, diminishingStart = 50, diminishingFactor = 0.8},
        agility = {walkSpeedPerPoint = 0.84, dashSpeedPerPoint = 0.04},
        perception = {
            rangePerPoint = 10,
            dashRangePerPoint = 0.05,
            cooldownReductionPerPoint = 0.02,
            maxCooldownReduction = 0.6,
            rampageDurationPerPoint = 2.1,
            behindYouCDReductionPerPoint = 0.15
        },
        vitality = {hpPerPoint = 20, regenPerPoint = 0.5, secondChanceThreshold = 10},
        intelligence = {xpPerPoint = 50, cooldownBonusPerPoint = 0.01}
    }
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“± MOBILE OPTIMIZER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local PhoneOptimizer = {
    isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
}

function PhoneOptimizer:getUpdateInterval()
    return self.isMobile and 0.15 or 0.1
end

function PhoneOptimizer:getVFXMultiplier()
    return self.isMobile and 0.65 or 1.0
end

if PhoneOptimizer.isMobile then
    local m = PhoneOptimizer:getVFXMultiplier()
    Config.VFX.SHADOW_PORTAL_PARTICLES = math.floor(Config.VFX.SHADOW_PORTAL_PARTICLES * m)
    Config.VFX.LEVEL_UP_PARTICLES = math.floor(Config.VFX.LEVEL_UP_PARTICLES * m)
    Config.VFX.RAMPAGE_AURA_DENSITY = math.floor(Config.VFX.RAMPAGE_AURA_DENSITY * m)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ’¾ LOCAL DATA PERSISTENCE (CLIENT-SIDE)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local DataModule = {}
local SAVE_FILE = "CodexWorkshop_SoloLeveling.json"

function DataModule.savePlayerData(data)
    pcall(function()
        local saveData = {
            stats = data.stats,
            level = data.level,
            xp = data.xp,
            availablePoints = data.availablePoints,
            shadowStepLevel = data.shadowStep.level,
            shadowStepUses = data.shadowStep.uses,
            maxHP = data.maxHP,
            timestamp = os.time()
        }
        
        local json = HttpService:JSONEncode(saveData)
        
        -- Client-side file storage (works in exploit environments)
        if writefile then
            writefile(SAVE_FILE, json)
        end
    end)
end

function DataModule.loadPlayerData()
    local success, data = pcall(function()
        if isfile and isfile(SAVE_FILE) then
            local json = readfile(SAVE_FILE)
            return HttpService:JSONDecode(json)
        end
        return nil
    end)
    
    return success and data or nil
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ¯ STATE MANAGER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local StateManager = {
    current = "CLOSED",
    canTransition = true,
    activeDescription = nil,
    systemLocked = false
}

function StateManager:setState(newState, lockDuration)
    if self.systemLocked then return false end
    
    local validTransitions = {
        CLOSED = {"OPENING", "LOCKED"},
        OPENING = {"OPEN", "CLOSING"},
        OPEN = {"CLOSING", "LOCKED"},
        CLOSING = {"CLOSED"},
        LOCKED = {"OPENING", "CLOSED", "OPEN"}
    }
    
    if not table.find(validTransitions[self.current] or {}, newState) then
        return false
    end
    
    self.current = newState
    
    if lockDuration then
        self.canTransition = false
        task.delay(lockDuration, function()
            self.canTransition = true
        end)
    end
    
    return true
end

function StateManager:canInteract()
    return self.current == "OPEN" and self.canTransition and not self.systemLocked
end

function StateManager:lock(duration)
    self.systemLocked = true
    if duration then
        task.delay(duration, function()
            self.systemLocked = false
        end)
    end
end

function StateManager:unlock()
    self.systemLocked = false
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ¬ ANIMATION LOCK
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local AnimationLock = {
    locks = {}
}

function AnimationLock:acquire(key, duration)
    if self.locks[key] then return false end
    self.locks[key] = true
    task.delay(duration, function()
        self.locks[key] = nil
    end)
    return true
end

function AnimationLock:isLocked(key)
    return self.locks[key] == true
end

function AnimationLock:release(key)
    self.locks[key] = nil
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“¢ NOTIFICATION QUEUE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local NotificationQueue = {
    queue = {},
    isPlaying = false,
    isPaused = false
}

function NotificationQueue:add(notification)
    table.insert(self.queue, notification)
    if not self.isPlaying then
        self:playNext()
    end
end

function NotificationQueue:playNext()
    if #self.queue == 0 then
        self.isPlaying = false
        return
    end
    
    if self.isPaused then return end
    
    self.isPlaying = true
    local notif = table.remove(self.queue, 1)
    
    task.spawn(function()
        self:spawnNotification(notif)
        task.wait(notif.duration or 1.5)
        self:playNext()
    end)
end

function NotificationQueue:spawnNotification(notif)
    if not rootPart then return end
    
    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(1, 1, 1)
    part.CFrame = rootPart.CFrame * CFrame.new(notif.offset)
    part.Parent = workspace

    local gui = Instance.new("BillboardGui")
    gui.Size = UDim2.new(0, 300, 0, 100)
    gui.AlwaysOnTop = true
    gui.StudsOffset = Vector3.new(0, 0, 0)
    gui.Parent = part

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = notif.text
    label.Font = Enum.Font.GothamBlack
    label.TextScaled = true
    label.TextColor3 = notif.color or Color3.fromRGB(255, 60, 60)
    label.TextStrokeTransparency = 0
    label.TextStrokeColor3 = Color3.new(0, 0, 0)
    label.Parent = gui

    TweenService:Create(part, TweenInfo.new(notif.duration or 1.5), {
        CFrame = part.CFrame * CFrame.new(0, 5, 0)
    }):Play()
    TweenService:Create(label, TweenInfo.new(notif.duration or 1.5), {
        TextTransparency = 1,
        TextStrokeTransparency = 1
    }):Play()

    Debris:AddItem(part, (notif.duration or 1.5) + 0.1)
end

function NotificationQueue:pause()
    self.isPaused = true
end

function NotificationQueue:resume()
    self.isPaused = false
    if not self.isPlaying and #self.queue > 0 then
        self:playNext()
    end
end

function NotificationQueue:clear()
    self.queue = {}
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ¯ FOLLOW CONTROLLER (FIXED)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local FollowController = {
    mainPart = nil,
    descriptionPart = nil,
    lastKnownCFrame = nil,
    teleportThreshold = 50,
    updateConnection = nil,
    isPaused = false,
    needsResync = false,
    dashCooldown = 0
}

function FollowController:initialize(part)
    self.mainPart = part
    self.lastKnownCFrame = rootPart.CFrame
    self:startFollowing()
end

function FollowController:setDescriptionPart(part)
    self.descriptionPart = part
end

function FollowController:detectTeleport()
    if not self.lastKnownCFrame or not rootPart then return false end
    
    local distance = (rootPart.CFrame.Position - self.lastKnownCFrame.Position).Magnitude
    self.lastKnownCFrame = rootPart.CFrame
    
    return distance > self.teleportThreshold
end

function FollowController:signalMovementOverride()
    self.needsResync = true
    self.isPaused = true
    self.dashCooldown = 0.5
    task.delay(0.5, function()
        self.isPaused = false
        self:forceResync()
    end)
end

function FollowController:forceResync()
    if not rootPart or not self.mainPart then return end
    
    local characterLook = rootPart.CFrame.LookVector
    local targetPos = rootPart.Position + (characterLook * 8) + Vector3.new(0, 2, 0)
    local lookAtPos = Vector3.new(rootPart.Position.X, self.mainPart.Position.Y, rootPart.Position.Z)
    
    self.mainPart.CFrame = CFrame.new(targetPos, lookAtPos)
    
    if self.descriptionPart and self.descriptionPart.Parent then
        self.descriptionPart.CFrame = self.mainPart.CFrame * CFrame.new(0, 0, 2)
    end
    
    self.needsResync = false
    self.lastKnownCFrame = rootPart.CFrame
end

function FollowController:smoothFollow()
    if not rootPart or not self.mainPart then return end
    if StateManager.systemLocked or self.isPaused then return end
    
    if self.dashCooldown > 0 then
        self.dashCooldown = math.max(0, self.dashCooldown - 0.1)
        return
    end
    
    if self:detectTeleport() or self.needsResync then
        self:forceResync()
        return
    end
    
    local distance = (self.mainPart.Position - rootPart.Position).Magnitude
    
    if distance > 25 then
        self:forceResync()
    elseif distance > 12 then
        local characterLook = rootPart.CFrame.LookVector
        local targetPos = rootPart.Position + (characterLook * 8) + Vector3.new(0, 2, 0)
        local lookAtPos = Vector3.new(rootPart.Position.X, self.mainPart.Position.Y, rootPart.Position.Z)
        self.mainPart.CFrame = self.mainPart.CFrame:Lerp(CFrame.new(targetPos, lookAtPos), 0.12)
    else
        local lookAtPos = Vector3.new(rootPart.Position.X, self.mainPart.Position.Y, rootPart.Position.Z)
        self.mainPart.CFrame = self.mainPart.CFrame:Lerp(CFrame.new(self.mainPart.Position, lookAtPos), 0.12)
    end
    
    if self.descriptionPart and self.descriptionPart.Parent then
        self.descriptionPart.CFrame = self.mainPart.CFrame * CFrame.new(0, 0, 2)
    end
end

function FollowController:startFollowing()
    if self.updateConnection then
        self.updateConnection:Disconnect()
    end
    
    self.updateConnection = RunService.Heartbeat:Connect(function()
        self:smoothFollow()
    end)
end

function FollowController:stopFollowing()
    if self.updateConnection then
        self.updateConnection:Disconnect()
        self.updateConnection = nil
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“Š ABILITY CODEX (SYSTEM-BASED DESCRIPTIONS)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local AbilityCodex = {
    ShadowStep = {
        name = "Shadow Step",
        category = "Movement",
        unlockLevel = 10,
        baseDescription = [[Teleports the user through shadows to a target location.

â€¢ Range scales with Perception stat
â€¢ Cooldown reduced by Perception & Intelligence
â€¢ Can pass through walls and obstacles
â€¢ Levels up with usage (max level 50)

Usage increases proficiency and reduces cooldown.]],
        
        getFullDescription = function(self, data)
            local range = Config.BASE_SHADOW_STEP_RANGE + (data.stats.perception * Config.STAT_CURVES.perception.rangePerPoint)
            local cdReduction = math.clamp(
                data.stats.perception * Config.STAT_CURVES.perception.cooldownReductionPerPoint,
                0,
                Config.STAT_CURVES.perception.maxCooldownReduction
            )
            local baseCooldown = Config.BASE_SHADOW_STEP_COOLDOWN * (1 - cdReduction)
            local finalCooldown = baseCooldown * math.max(
                1 - (data.stats.intelligence * Config.STAT_CURVES.intelligence.cooldownBonusPerPoint),
                0.5
            )
            
            return string.format([[%s

CURRENT STATS:
â€¢ Range: %.1f studs
â€¢ Cooldown: %.1f seconds
â€¢ Level: %d/50
â€¢ Mastery: %d/%d uses to next level

SCALING:
â€¢ +10 range per Perception point
â€¢ -2%% cooldown per Perception point
â€¢ -1%% cooldown per Intelligence point]], 
                self.baseDescription, 
                range, 
                finalCooldown, 
                data.shadowStep.level,
                data.shadowStep.uses,
                data.shadowStep.level <= 10 and 5 or 8
            )
        end
    },
    
    Rampage = {
        name = "Rampage",
        category = "Ultimate",
        unlockLevel = 25,
        baseDescription = [[Enters an awakened state, maxing all stats temporarily.

â€¢ Duration: 90 seconds (base) + Perception scaling
â€¢ All stats set to 100 during activation
â€¢ Unlock "Behind You" ability during Rampage
â€¢ Cooldown: 300 seconds base
â€¢ Requires 5 kills to recharge after use

ACTIVATION EFFECTS:
â€¢ Dramatic awakening cutscene
â€¢ Screen tremors and visual effects
â€¢ Permanent red aura while active]],
        
        getFullDescription = function(self, data)
            local duration = math.min(
                90 + (data.stats.perception * Config.STAT_CURVES.perception.rampageDurationPerPoint),
                300
            )
            
            return string.format([[%s

CURRENT STATS:
â€¢ Duration: %.0f seconds
â€¢ Cooldown: %s
â€¢ Kills to recharge: %d/5

SCALING:
â€¢ +2.1 seconds duration per Perception point
â€¢ Maximum duration: 300 seconds]], 
                self.baseDescription,
                duration,
                data.rampage.cooldown > 0 and string.format("%.0fs", data.rampage.cooldown) or "READY",
                data.rampage.currentKills
            )
        end
    },
    
    BehindYou = {
        name = "Behind You",
        category = "Rampage-Only",
        unlockLevel = 25,
        baseDescription = [[Instantly teleports behind a distant enemy.

â€¢ RAMPAGE MODE EXCLUSIVE
â€¢ Range: 100-500 studs
â€¢ Targets nearest valid enemy in range
â€¢ Repositions behind target's back
â€¢ Enhanced visual effects

REQUIREMENTS:
â€¢ Rampage must be active
â€¢ Enemy must be 100-500 studs away
â€¢ Line of sight not required]],
        
        getFullDescription = function(self, data)
            local cooldown = math.max(
                20 * (1 - math.clamp(data.stats.perception * Config.STAT_CURVES.perception.behindYouCDReductionPerPoint, 0, 0.75)),
                5
            )
            
            return string.format([[%s

CURRENT STATS:
â€¢ Cooldown: %.1f seconds
â€¢ Min Range: %d studs
â€¢ Max Range: %d studs

SCALING:
â€¢ -15%% cooldown per Perception point
â€¢ Minimum cooldown: 5 seconds
â€¢ Maximum reduction: 75%%]], 
                self.baseDescription,
                cooldown,
                Config.BEHIND_YOU_MIN_RANGE,
                Config.BEHIND_YOU_MAX_RANGE
            )
        end
    }
}

-- System function to get ability info without UI
function AbilityCodex:getAbilityInfo(abilityName, playerData)
    local ability = self[abilityName]
    if not ability then return nil end
    
    return {
        name = ability.name,
        category = ability.category,
        unlockLevel = ability.unlockLevel,
        description = ability:getFullDescription(playerData)
    }
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“Š PLAYER DATA
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local savedData = DataModule.loadPlayerData()

local PlayerData = {
    stats = savedData and savedData.stats or {
        strength = 0,
        agility = 0,
        perception = 0,
        vitality = 0,
        intelligence = 0
    },
    level = savedData and savedData.level or 1,
    xp = savedData and savedData.xp or 0,
    maxHP = savedData and savedData.maxHP or 100,
    availablePoints = savedData and savedData.availablePoints or 5,
    shadowStep = {
        level = savedData and savedData.shadowStepLevel or 1,
        uses = savedData and savedData.shadowStepUses or 0,
        unlocked = false,
        cooldown = 0,
        isActive = false
    },
    rampage = {
        unlocked = false,
        isActive = false,
        duration = 90,
        cooldown = 0,
        maxCooldown = 300,
        killsRequired = 5,
        currentKills = 0
    },
    behindYou = {
        cooldown = 0,
        maxCooldown = 20,
        minCooldown = 5
    },
    combatEngagement = {},
    assistEngagement = {},
    hasSecondChance = true
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“ˆ RANK DATA
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local RankData = {
    {name = "E-RANK", level = 1, color = Color3.fromRGB(176, 176, 176), title = "The Weakest Hunter", status = "NORMAL"},
    {name = "D-RANK", level = 10, color = Color3.fromRGB(79, 195, 247), title = "Awakened", status = "NORMAL"},
    {name = "C-RANK", level = 20, color = Color3.fromRGB(76, 175, 80), title = "Elite Hunter", status = "NORMAL"},
    {name = "B-RANK", level = 35, color = Color3.fromRGB(255, 193, 7), title = "Elite Hunter", status = "HIGH"},
    {name = "A-RANK", level = 50, color = Color3.fromRGB(255, 112, 67), title = "Apex Hunter", status = "RARE"},
    {name = "S-RANK", level = 70, color = Color3.fromRGB(211, 47, 47), title = "National Threat", status = "EXTREMELY RARE"},
    {name = "NATIONAL", level = 90, color = Color3.fromRGB(138, 43, 226), title = "National Power", status = "CLASSIFIED"},
    {name = "MONARCH", level = 100, color = Color3.fromRGB(0, 0, 0), title = "Shadow Monarch", status = "UNKNOWN"}
}

local StatInfo = {
    strength = {
        name = "Strength",
        abbr = "STR",
        color = Color3.fromRGB(239, 68, 68),
        title = "ğŸŸ¥ Physical Power",
        description = "Increases physical power.\n\nâ€¢ +2% damage per point\nâ€¢ Diminishing after 50",
        getEffect = function(val)
            local dmg = val * 2
            if val > 50 then
                dmg = 50 * 2 + ((val - 50) * 2 * 0.8)
            end
            return string.format("+%d%% DMG", math.floor(dmg))
        end
    },
    vitality = {
        name = "Vitality",
        abbr = "VIT",
        color = Color3.fromRGB(168, 85, 247),
        title = "ğŸŸª Body Toughness",
        description = "Improves endurance.\n\nâ€¢ +20 HP per point\nâ€¢ +0.5 HP regen/s\nâ€¢ Second Chance (10+ VIT)",
        getEffect = function(val)
            return string.format("+%d HP", val * 20)
        end
    },
    agility = {
        name = "Agility",
        abbr = "AGI",
        color = Color3.fromRGB(34, 197, 94),
        title = "ğŸŸ© Speed & Movement",
        description = "Increases movement speed.\n\nâ€¢ Walk speed to cap (100)\nâ€¢ +4% dash speed",
        getEffect = function(val)
            return string.format("+%d SPD", math.floor(val * 0.84))
        end
    },
    intelligence = {
        name = "Intelligence",
        abbr = "INT",
        color = Color3.fromRGB(59, 130, 246),
        title = "ğŸŸ¦ Tactical Mind",
        description = "Increases XP and efficiency.\n\nâ€¢ +50 XP per kill\nâ€¢ -1% cooldown",
        getEffect = function(val)
            return string.format("+%d XP", val * 50)
        end
    },
    perception = {
        name = "Perception",
        abbr = "PER",
        color = Color3.fromRGB(250, 204, 21),
        title = "ğŸŸ¨ Battle Control",
        description = "Improves ability range.\n\nâ€¢ +10 studs range\nâ€¢ +5% dash range\nâ€¢ -2% cooldown",
        getEffect = function(val)
            return string.format("+%d RNG", val * 10)
        end
    }
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ§® STAT CALCULATOR
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local StatCalculator = {}

function StatCalculator.applyStatEffects()
    if not humanoid then return end
    
    local stats = PlayerData.stats
    local curves = Config.STAT_CURVES
    local healthPercent = humanoid.Health / humanoid.MaxHealth
    
    humanoid.WalkSpeed = math.min(
        Config.BASE_WALK_SPEED + (stats.agility * curves.agility.walkSpeedPerPoint),
        Config.MAX_WALK_SPEED
    )
    
    _G.dashSpeed = Config.BASE_DASH_SPEED * (1 + stats.agility * curves.agility.dashSpeedPerPoint)
    _G.dashRange = Config.BASE_DASH_RANGE * (1 + stats.perception * curves.perception.dashRangePerPoint)
    _G.shadowStepRange = Config.BASE_SHADOW_STEP_RANGE + (stats.perception * curves.perception.rangePerPoint)
    
    local cdReduction = math.clamp(
        stats.perception * curves.perception.cooldownReductionPerPoint,
        0,
        curves.perception.maxCooldownReduction
    )
    _G.shadowStepMaxCooldown = Config.BASE_SHADOW_STEP_COOLDOWN * (1 - cdReduction)
    _G.shadowStepMaxCooldown = _G.shadowStepMaxCooldown * math.max(
        1 - (stats.intelligence * curves.intelligence.cooldownBonusPerPoint),
        0.5
    )
    
    PlayerData.rampage.duration = math.min(
        90 + (stats.perception * curves.perception.rampageDurationPerPoint),
        300
    )
    
    PlayerData.behindYou.maxCooldown = math.max(
        20 * (1 - math.clamp(stats.perception * curves.perception.behindYouCDReductionPerPoint, 0, 0.75)),
        PlayerData.behindYou.minCooldown
    )
    
    PlayerData.maxHP = 100 + (stats.vitality * curves.vitality.hpPerPoint)
    humanoid.MaxHealth = PlayerData.maxHP
    humanoid.Health = PlayerData.maxHP * healthPercent
    
    PlayerData.hasSecondChance = stats.vitality >= curves.vitality.secondChanceThreshold
    
    DataModule.savePlayerData(PlayerData)
end

function StatCalculator.getDamageMultiplier()
    local str = PlayerData.stats.strength
    local damage = str * 2
    if str > 50 then
        damage = 50 * 2 + ((str - 50) * 2 * 0.8)
    end
    return 1 + (damage / 100)
end

function StatCalculator.getXPBonus()
    return PlayerData.stats.intelligence * 50
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“Š LEVEL SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local LevelSystem = {}

function LevelSystem.calculateRequiredXP(level)
    return math.floor(100 * (level ^ 1.15))
end

function LevelSystem.getCurrentRank()
    for i = #RankData, 1, -1 do
        if PlayerData.level >= RankData[i].level then
            return RankData[i]
        end
    end
    return RankData[1]
end

function Level
System.getCurrentClass()
if PlayerData.level >= 100 then return "Shadow Monarch"
elseif PlayerData.level >= 71 then return "Shadow Commander"
elseif PlayerData.level >= 41 then return "Shadow Warrior"
elseif PlayerData.level >= 21 then return "Shadow Adept"
else return "Unclassified" end
end
function LevelSystem.grantXP(amount)
if PlayerData.rampage.isActive then return end
PlayerData.xp = PlayerData.xp + amount
local maxXP = LevelSystem.calculateRequiredXP(PlayerData.level)

while PlayerData.xp >= maxXP and PlayerData.level < Config.LEVEL_CAP do
    PlayerData.xp = PlayerData.xp - maxXP
    PlayerData.level = PlayerData.level + 1
    PlayerData.availablePoints = PlayerData.availablePoints + Config.POINTS_PER_LEVEL
    
    task.spawn(function()
        EffectsModule.createLevelUpEffect()
    end)
    
    PlayerData.maxHP = 100 + (PlayerData.stats.vitality * 20)
    humanoid.MaxHealth = PlayerData.maxHP
    humanoid.Health = PlayerData.maxHP
    
    if PlayerData.level >= Config.SHADOW_STEP_UNLOCK_LEVEL and not PlayerData.shadowStep.unlocked then
        PlayerData.shadowStep.unlocked = true
        UIModule.updateAbilityButtons()
    end
    
    if PlayerData.level >= Config.RAMPAGE_UNLOCK_LEVEL and not PlayerData.rampage.unlocked then
        PlayerData.rampage.unlocked = true
        UIModule.updateAbilityButtons()
        task.spawn(function()
            EffectsModule.createRampageUnlockEffect()
        end)
    end
    
    maxXP = LevelSystem.calculateRequiredXP(PlayerData.level)
end

UIModule.updateUI()
DataModule.savePlayerData(PlayerData)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âš”ï¸ COMBAT SYSTEM (PERFECT KILL/ASSIST TRACKING)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local CombatModule = {}
function CombatModule.recordDamage(victimUserId, damage)
local currentTime = tick()
if not PlayerData.combatEngagement[victimUserId] then
    PlayerData.combatEngagement[victimUserId] = {
        totalDamage = 0,
        lastHit = currentTime,
        firstHit = currentTime
    }
end

PlayerData.combatEngagement[victimUserId].totalDamage = PlayerData.combatEngagement[victimUserId].totalDamage + damage
PlayerData.combatEngagement[victimUserId].lastHit = currentTime
end
function CombatModule.recordAssist(victimUserId, attackerPlayer)
local currentTime = tick()
if not PlayerData.assistEngagement[victimUserId] then
    PlayerData.assistEngagement[victimUserId] = {
        primaryAttacker = attackerPlayer,
        lastSeen = currentTime,
        playerDamaged = false
    }
end

PlayerData.assistEngagement[victimUserId].lastSeen = currentTime
end
function CombatModule.validateKill(victimUserId)
local engagement = PlayerData.combatEngagement[victimUserId]
if not engagement then return false end
local currentTime = tick()
local timeSinceLastHit = currentTime - engagement.lastHit
local sufficientDamage = engagement.totalDamage >= Config.MIN_DAMAGE_FOR_CREDIT

return timeSinceLastHit <= Config.COMBAT_TIMEOUT and sufficientDamage
end
function CombatModule.validateAssist(victimUserId)
local assist = PlayerData.assistEngagement[victimUserId]
if not assist then return false end
local currentTime = tick()
local timeSinceLastSeen = currentTime - assist.lastSeen

return timeSinceLastSeen <= Config.ASSIST_TIME_WINDOW and assist.playerDamaged
end
function CombatModule.onPlayerKilled(victim, killer)
if not victim or not victim.UserId then return end
local userId = victim.UserId
local totalXP = 0
-- Check if player gets kill credit
if killer == player and CombatModule.validateKill(userId) then
    totalXP = Config.BASE_KILL_XP + StatCalculator.getXPBonus()
    LevelSystem.grantXP(totalXP)
    
    -- Rampage kill counter
    if PlayerData.rampage.cooldown > 0 then
        PlayerData.rampage.currentKills = PlayerData.rampage.currentKills + 1
        if PlayerData.rampage.currentKills >= PlayerData.rampage.killsRequired then
            PlayerData.rampage.cooldown = 0
            PlayerData.rampage.currentKills = 0
            NotificationQueue:add({
                text = "RAMPAGE READY",
                offset = Vector3.new(0, 3, 0),
                duration = 1.5,
                color = Color3.fromRGB(255, 60, 60)
            })
        end
    end
    
    if rootPart then
        task.spawn(function()
            EffectsModule.createXPPopup(totalXP, rootPart.Position, "KILL")
        end)
    end
    
    PlayerData.combatEngagement[userId] = nil
    
-- Check if player gets assist credit
elseif killer ~= player and CombatModule.validateAssist(userId) then
    totalXP = math.floor((Config.BASE_KILL_XP + StatCalculator.getXPBonus()) * Config.ASSIST_XP_MULTIPLIER)
    LevelSystem.grantXP(totalXP)
    
    if rootPart then
        task.spawn(function()
            EffectsModule.createXPPopup(totalXP, rootPart.Position, "ASSIST")
        end)
    end
    
    PlayerData.assistEngagement[userId] = nil
end
end
-- Monitor player health changes for damage tracking
function CombatModule.setupHealthMonitoring(otherPlayer)
if not otherPlayer or not otherPlayer.Character then return end
local otherHumanoid = otherPlayer.Character:FindFirstChild("Humanoid")
if not otherHumanoid or otherHumanoid:GetAttribute("Monitored") then return end

otherHumanoid:SetAttribute("Monitored", true)

local lastHealth = otherHumanoid.Health

otherHumanoid.HealthChanged:Connect(function(health)
    if health < lastHealth and rootPart and otherPlayer.Character then
        local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
        
        if otherRoot then
            local distance = (rootPart.Position - otherRoot.Position).Magnitude
            local damage = lastHealth - health
            
            -- Direct combat range (player dealt damage)
            if distance <= 35 then
                CombatModule.recordDamage(otherPlayer.UserId, damage)
            
            -- Assist range (player nearby but didn't deal damage)
            elseif distance <= Config.ASSIST_RANGE then
                for _, p in pairs(Players:GetPlayers()) do
                    if p ~= player and p ~= otherPlayer and p.Character then
                        local pRoot = p.Character:FindFirstChild("HumanoidRootPart")
                        if pRoot and (pRoot.Position - otherRoot.Position).Magnitude <= 35 then
                            CombatModule.recordAssist(otherPlayer.UserId, p)
                            if PlayerData.assistEngagement[otherPlayer.UserId] then
                                PlayerData.assistEngagement[otherPlayer.UserId].playerDamaged = true
                            end
                            break
                        end
                    end
                end
            end
        end
    end
    
    lastHealth = health
end)

otherHumanoid.Died:Connect(function()
    -- Find who killed them
    local killer = player -- Assume player killed if we have combat engagement
    
    if not CombatModule.validateKill(otherPlayer.UserId) then
        -- Check for other nearby players who might have killed them
        for _, p in pairs(Players:GetPlayers()) do
            if p ~= player and p.Character then
                local pRoot = p.Character:FindFirstChild("HumanoidRootPart")
                local otherRoot = otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart")
                if pRoot and otherRoot and (pRoot.Position - otherRoot.Position).Magnitude <= 35 then
                    killer = p
                    break
                end
            end
        end
    end
    
    CombatModule.onPlayerKilled(otherPlayer, killer)
end)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ¨ EFFECTS MODULE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EffectsModule = {}
function EffectsModule.createXPPopup(amount, position, type)
if PlayerData.rampage.isActive then return end
local part = Instance.new("Part")
part.Size = Vector3.new(5, 3, 0.1)
part.Position = position + Vector3.new(0, 4, 0)
part.Anchored = true
part.CanCollide = false
part.Transparency = 1
part.Parent = workspace
local gui = Instance.new("BillboardGui")
gui.Size = UDim2.new(0, 300, 0, 150)
gui.StudsOffset = Vector3.new(0, 2, 0)
gui.AlwaysOnTop = true
gui.Parent = part

local label = Instance.new("TextLabel")
label.Size = UDim2.new(1, 0, 1, 0)
label.BackgroundTransparency = 1
label.Font = Enum.Font.GothamBold
label.TextSize = type == "KILL" and 36 or 28
label.Text = type == "KILL" and ("+" .. amount .. " XP") or ("+" .. amount .. " XP [ASSIST]")
label.TextColor3 = type == "KILL" and Color3.fromRGB(34, 211, 238) or Color3.fromRGB(250, 204, 21)
label.Parent = gui

TweenService:Create(gui, TweenInfo.new(1.5), {StudsOffset = Vector3.new(0, 5, 0)}):Play()
TweenService:Create(label, TweenInfo.new(1.5), {TextTransparency = 1}):Play()
Debris:AddItem(part, 1.5)
end
function EffectsModule.createLevelUpEffect()
if not rootPart then return end
-- Triple pillar effect
for i = 1, 3 do
    task.spawn(function()
        local pillar = Instance.new("Part")
        pillar.Size = Vector3.new(10, 60, 10)
        pillar.Position = rootPart.Position
        pillar.Anchored = true
        pillar.CanCollide = false
        pillar.Material = Enum.Material.Neon
        pillar.Color = i == 1 and Color3.fromRGB(255, 215, 0) or i == 2 and Color3.fromRGB(255, 165, 0) or Color3.fromRGB(255, 255, 255)
        pillar.Transparency = 0.3 + (i * 0.1)
        pillar.Parent = workspace
        
        local mesh = Instance.new("CylinderMesh")
        mesh.Parent = pillar
        
        task.wait(i * 0.1)
        
        TweenService:Create(pillar, TweenInfo.new(1.2), {
            Transparency = 1,
            Size = Vector3.new(15 + (i * 2), 60, 15 + (i * 2))
        }):Play()
        
        Debris:AddItem(pillar, 1.2)
    end)
end

-- Explosion wave
local wave = Instance.new("Part")
wave.Size = Vector3.new(2, 0.5, 2)
wave.Position = rootPart.Position
wave.Anchored = true
wave.CanCollide = false
wave.Material = Enum.Material.Neon
wave.Color = Color3.fromRGB(255, 215, 0)
wave.Transparency = 0.3
wave.Parent = workspace

local mesh = Instance.new("CylinderMesh")
mesh.Parent = wave

TweenService:Create(wave, TweenInfo.new(0.8), {
    Size = Vector3.new(40, 0.5, 40),
    Transparency = 1
}):Play()

Debris:AddItem(wave, 0.8)

-- Enhanced particles
for i = 1, Config.VFX.LEVEL_UP_PARTICLES do
    task.spawn(function()
        local part = Instance.new("Part")
        part.Size = Vector3.new(0.8, 0.8, 0.8)
        part.Position = rootPart.Position + Vector3.new(
            math.random(-4, 4),
            math.random(-2, 4),
            math.random(-4, 4)
        )
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.Color = i % 2 == 0 and Color3.fromRGB(255, 215, 0) or Color3.fromRGB(255, 255, 255)
        part.Shape = Enum.PartType.Ball
        part.Parent = workspace
        
        TweenService:Create(part, TweenInfo.new(1.5), {
            Position = part.Position + Vector3.new(
                math.random(-6, 6),
                math.random(8, 15),
                math.random(-6, 6)
            ),
            Transparency = 1,
            Size = Vector3.new(0.1, 0.1, 0.1)
        }):Play()
        
        Debris:AddItem(part, 1.5)
    end)
end
end
function EffectsModule.createStatUpgradeEffect(statName)
if not rootPart then return end
local statColor = StatInfo[statName].color
for i = 1, Config.VFX.STAT_UPGRADE_ORBS do
    local angle = (i / Config.VFX.STAT_UPGRADE_ORBS) * math.pi * 2
    local part = Instance.new("Part")
    part.Size = Vector3.new(0.8, 0.8, 0.8)
    part.Shape = Enum.PartType.Ball
    part.Position = rootPart.Position + Vector3.new(
        math.cos(angle) * 3,
        2,
        math.sin(angle) * 3
    )
    part.Anchored = true
    part.CanCollide = false
    part.Material = Enum.Material.Neon
    part.Color = statColor
    part.Parent = workspace
    
    TweenService:Create(part, TweenInfo.new(0.8), {
        Position = rootPart.Position + Vector3.new(0, 2, 0),
        Transparency = 1,
        Size = Vector3.new(0.2, 0.2, 0.2)
    }):Play()
    
    Debris:AddItem(part, 0.8)
end
end
function EffectsModule.createShadowPortal(position)
local portal = Instance.new("Part")
portal.Size = Vector3.new(6, 0.4, 6)
portal.Position = position
portal.Anchored = true
portal.CanCollide = false
portal.Material = Enum.Material.Neon
portal.Color = Color3.fromRGB(10, 10, 10)
portal.Transparency = 0.2
portal.Parent = workspace
local rim = Instance.new("Part")
rim.Size = Vector3.new(7, 0.5, 7)
rim.Position = position
rim.Anchored = true
rim.CanCollide = false
rim.Material = Enum.Material.Neon
rim.Color = Color3.fromRGB(138, 43, 226)
rim.Transparency = 0.4
rim.Parent = workspace

Instance.new("CylinderMesh").Parent = rim
Instance.new("CylinderMesh").Parent = portal

for i = 1, Config.VFX.SHADOW_PORTAL_PARTICLES do
    local particle = Instance.new("Part")
    particle.Size = Vector3.new(0.3, 0.3, 0.3)
    particle.Position = position + Vector3.new(
        math.random(-3, 3),
        0.5,
        math.random(-3, 3)
    )
    particle.Anchored = true
    particle.CanCollide = false
    particle.Material = Enum.Material.Neon
    particle.Color = Color3.fromRGB(138, 43, 226)
    particle.Transparency = 0.5
    particle.Parent = workspace
    
    TweenService:Create(particle, TweenInfo.new(0.5), {
        Position = position + Vector3.new(0, 3, 0),
        Transparency = 1
    }):Play()
    
    Debris:AddItem(particle, 0.5)
end

TweenService:Create(portal, TweenInfo.new(0.5), {
    Transparency = 1,
    Size = Vector3.new(10, 0.4, 10)
}):Play()

TweenService:Create(rim, TweenInfo.new(0.5), {
    Transparency = 1,
    Size = Vector3.new(12, 0.5, 12)
}):Play()

Debris:AddItem(portal, 0.5)
Debris:AddItem(rim, 0.5)
end
function EffectsModule.createShadowStepTrail(startPos, endPos)
for i = 1, 10 do
local progress = i / 10
local pos = startPos:Lerp(endPos, progress)
local trail = Instance.new("Part")
trail.Size = Vector3.new(1.5, 3, 1.5)
trail.Position = pos
trail.Anchored = true
trail.CanCollide = false
trail.Material = Enum.Material.Neon
trail.Color = Color3.fromRGB(138, 43, 226)
trail.Transparency = 0.3
trail.Parent = workspace
TweenService:Create(trail, TweenInfo.new(0.4), {
        Transparency = 1,
        Size = Vector3.new(0.5, 1, 0.5)
    }):Play()
    
    Debris:AddItem(trail, 0.4)
end
end
function EffectsModule.createSecondChanceEffect()
if not rootPart then return end
for i = 1, 20 do
local part = Instance.new("Part")
part.Size = Vector3.new(0.8, 0.8, 0.8)
part.Position = rootPart.Position + Vector3.new(
math.random(-2, 2),
math.random(0, 3),
math.random(-2, 2)
)
part.Anchored = true
part.CanCollide = false
part.Material = Enum.Material.Neon
part.Color = Color3.fromRGB(168, 85, 247)
part.Transparency = 0.3
part.Parent = workspace
TweenService:Create(part, TweenInfo.new(1.2), {
        Position = rootPart.Position,
        Transparency = 1,
        Size = Vector3.new(0.2, 0.2, 0.2)
    }):Play()
    
    Debris:AddItem(part, 1.2)
end
end
function EffectsModule.createRampageUnlockEffect()
if not rootPart then return end
local playerGui = player:WaitForChild("PlayerGui")
local flash = Instance.new("Frame")
flash.Size = UDim2.new(1, 0, 1, 0)
flash.BackgroundColor3 = Color3.fromRGB(211, 47, 47)
flash.BackgroundTransparency = 0
flash.BorderSizePixel = 0
flash.ZIndex = 100
flash.Parent = playerGui
TweenService:Create(flash, TweenInfo.new(1.5), {
    BackgroundTransparency = 1
}):Play()

Debris:AddItem(flash, 1.5)

NotificationQueue:add({
    text = "RAMPAGE UNLOCKED",
    offset = Vector3.new(0, 3, 0),
    duration = 2,
    color = Color3.fromRGB(255, 60, 60)
})
end
function EffectsModule.createRampageCutscene()
local camera = workspace.CurrentCamera
local originalCFrame = camera.CFrame
local originalFOV = camera.FieldOfView
StateManager:lock(6.5)
NotificationQueue:pause()
NotificationQueue:clear()
humanoid.WalkSpeed = 0
humanoid.JumpPower = 0
-- Screen flash
local playerGui = player:WaitForChild("PlayerGui")
local redFlash = Instance.new("Frame")
redFlash.Size = UDim2.new(1, 0, 1, 0)
redFlash.BackgroundColor3 = Color3.fromRGB(139, 0, 0)
redFlash.BackgroundTransparency = 1
redFlash.BorderSizePixel = 0
redFlash.ZIndex = 99
redFlash.Parent = playerGui

-- Phase 1: Ground cracks with intensity
for i = 1, 16 do
    task.spawn(function()
        local angle = (i / 16) * math.pi * 2
        local crack = Instance.new("Part")
        crack.Size = Vector3.new(1.5, 0.8, 12)
        crack.Position = rootPart.Position + Vector3.new(
            math.cos(angle) * 5,
            -2.5,
            math.sin(angle) * 5
        )
        crack.Anchored = true
        crack.CanCollide = false
        crack.Material = Enum.Material.Neon
        crack.Color = Color3.fromRGB(139, 0, 0)
        crack.Transparency = 0.2
        crack.Parent = workspace
        
        TweenService:Create(crack, TweenInfo.new(0.6), {
            Size = Vector3.new(2, 0.8, 20),
            Transparency = 1
        }):Play()
        
        Debris:AddItem(crack, 0.6)
    end)
end

-- Phase 2: Intense camera shake + FOV
task.spawn(function()
    for i = 1, 80 do
        local intensity = (i <= 40 and (i / 40) or (80 - i) / 40) * 1.5
        camera.CFrame = originalCFrame * CFrame.Angles(
            math.rad(math.random(-8, 8) * intensity),
            math.rad(math.random(-8, 8) * intensity),
            math.rad(math.random(-5, 5) * intensity)
        )
        camera.FieldOfView = originalFOV + (math.sin(i / 5) * 10 * intensity)
        task.wait(0.025)
    end
    camera.CFrame = originalCFrame
    camera.FieldOfView = originalFOV
end)

-- Flash pulse
task.spawn(function()
    for i = 1, 4 do
        TweenService:Create(redFlash, TweenInfo.new(0.15), {BackgroundTransparency = 0.3}):Play()
        task.wait(0.15)
        TweenService:Create(redFlash, TweenInfo.new(0.15), {BackgroundTransparency = 0.9}):Play()
        task.wait(0.4)
    end
end)

-- Phase 3: Notifications
task.wait(2)
NotificationQueue:add({
    text = "AWAKENING",
    offset = Vector3.new(0, 5, 0),
    duration = 1.2,
    color = Color3.fromRGB(255, 60, 60)
})
task.wait(1.2)

local statOrder = {"strength", "perception", "agility", "vitality", "intelligence"}
for i, statName in ipairs(statOrder) do
    local angle = ((i - 1) / #statOrder) * math.pi * 2
    local offset = Vector3.new(
        math.cos(angle) * 4,
        4,
        math.sin(angle) * 4
    )
    NotificationQueue:add({
        text = StatInfo[statName].abbr .. ": 100",
        offset = offset,
        duration = 0.5,
        color = StatInfo[statName].color
    })
end

task.wait(0.7)
NotificationQueue:add({
    text = "RAMPAGE MODE",
    offset = Vector3.new(0, 6, 0),
    duration = 2,
    color = Color3.fromRGB(139, 0, 0)
})

-- Phase 4: Massive explosion
task.wait(1.8)

TweenService:Create(redFlash, TweenInfo.new(0.1), {BackgroundTransparency = 0}):Play()
task.wait(0.1)
TweenService:Create(redFlash, TweenInfo.new(0.8), {BackgroundTransparency = 1}):Play()

local explosion = Instance.new("Part")
explosion.Size = Vector3.new(8, 8, 8)
explosion.Position = rootPart.Position
explosion.Anchored = true
explosion.CanCollide = false
explosion.Material = Enum.Material.Neon
explosion.Color = Color3.fromRGB(139, 0, 0)
explosion.Transparency = 0.2
explosion.Shape = Enum.PartType.Ball
explosion.Parent = workspace

TweenService:Create(explosion, TweenInfo.new(0.6), {
    Size = Vector3.new(80, 80, 80),
    Transparency = 1
}):Play()

Debris:AddItem(explosion, 0.6)
Debris:AddItem(redFlash, 1)

task.wait(0.7)
NotificationQueue:resume()
end
function EffectsModule.createRampageAura()
if not rootPart then return end
local auraConnection
auraConnection = RunService.Heartbeat:Connect(function()
if not PlayerData.rampage.isActive or not rootPart then
auraConnection:Disconnect()
return
end
if math.random() > 0.6 then
        local aura = Instance.new("Part")
        aura.Size = Vector3.new(1.2, 1.2, 1.2)
        aura.Position = rootPart.Position + Vector3.new(
            math.random(-3, 3),
            math.random(-1, 3),
            math.random(-3, 3)
        )
        aura.Anchored = true
        aura.CanCollide = false
        aura.Material = Enum.Material.Neon
        aura.Color = Color3.fromRGB(139, 0, 0)
        aura.Transparency = 0.3
        aura.Parent = workspace
        
        TweenService:Create(aura, TweenInfo.new(0.7), {
            Position = aura.Position + Vector3.new(0, 3, 0),
            Transparency = 1,
            Size = Vector3.new(0.2, 0.2, 0.2)
        }):Play()
        
        Debris:AddItem(aura, 0.7)
    end
end)
end
function EffectsModule.createBehindYouEffect(startPos, targetPos)
EffectsModule.createShadowPortal(startPos)
local fadeClone = character:Clone()
for _, part in pairs(fadeClone:GetDescendants()) do
if part:IsA("BasePart") then
part.Anchored = true
part.CanCollide = false
part.Material = Enum.Material.Neon
part.Color = Color3.fromRGB(138, 43, 226)
TweenService:Create(part, TweenInfo.new(0.3), {
Transparency = 1
}):Play()
end
end
fadeClone.Parent = workspace
Debris:AddItem(fadeClone, 0.3)
for i = 1, 15 do
    task.spawn(function()
        local progress = i / 15
        local pos = startPos:Lerp(targetPos, progress)
        local shadow = Instance.new("Part")
        shadow.Size = Vector3.new(2, 4, 2)
        shadow.Position = pos
        shadow.Anchored = true
        shadow.CanCollide = false
        shadow.Material = Enum.Material.Neon
        shadow.Color = Color3.fromRGB(75, 0, 130)
        shadow.Transparency = 0.5
        shadow.Parent = workspace
        
        TweenService:Create(shadow, TweenInfo.new(0.5), {
            Transparency = 1,
            Size = Vector3.new(0.5, 1, 0.5)
        }):Play()
        
        Debris:AddItem(shadow, 0.5)
    end)
end

task.wait(0.15)
EffectsModule.createShadowPortal(targetPos)

for i = 1, Config.VFX.BEHIND_YOU_SMOKE do
    task.spawn(function()
        local smoke = Instance.new("Part")
        smoke.Size = Vector3.new(1, 1, 1)
        smoke.Position = targetPos + Vector3.new(
math.random(-2, 2),
math.random(0, 3),
math.random(-2, 2)
)
smoke.Anchored = true
smoke.CanCollide = false
smoke.Material = Enum.Material.Neon
smoke.Color = Color3.fromRGB(75, 0, 130)
smoke.Transparency = 0.3
smoke.Parent = workspace
local mesh = Instance.new("SpecialMesh")
        mesh.MeshType = Enum.MeshType.Sphere
        mesh.Parent = smoke
        
        TweenService:Create(smoke, TweenInfo.new(0.6), {
            Position = smoke.Position + Vector3.new(
                math.random(-4, 4),
                math.random(2, 5),
                math.random(-4, 4)
            ),
            Size = Vector3.new(2, 2, 2),
            Transparency = 1
        }):Play()
        
        Debris:AddItem(smoke, 0.6)
    end)
end

local arrivalShock = Instance.new("Part")
arrivalShock.Size = Vector3.new(2, 0.5, 2)
arrivalShock.Position = targetPos
arrivalShock.Anchored = true
arrivalShock.CanCollide = false
arrivalShock.Material = Enum.Material.Neon
arrivalShock.Color = Color3.fromRGB(138, 43, 226)
arrivalShock.Transparency = 0.3
arrivalShock.Parent = workspace

Instance.new("CylinderMesh").Parent = arrivalShock

TweenService:Create(arrivalShock, TweenInfo.new(0.5), {
    Size = Vector3.new(15, 0.5, 15),
    Transparency = 1
}):Play()

Debris:AddItem(arrivalShock, 0.5)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âš¡ ABILITY SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local AbilityModule = {}
function AbilityModule.performShadowStep()
if PlayerData.shadowStep.isActive
or PlayerData.shadowStep.cooldown > 0
or not PlayerData.shadowStep.unlocked
or not rootPart
or PlayerData.rampage.isActive
or not AnimationLock:acquire("shadow_step", 0.5)
or not InputAuthority:canUseAbility()
then
return
end
InputAuthority:lockAbilities(0.5)
PlayerData.shadowStep.isActive = true

local camera = workspace.CurrentCamera
local lookVector = camera.CFrame.LookVector
local targetPos = rootPart.Position + (lookVector * (_G.shadowStepRange or 50))

local rayParams = RaycastParams.new()
rayParams.FilterDescendantsInstances = {character}
rayParams.FilterType = Enum.RaycastFilterType.Exclude

local ray = workspace:Raycast(rootPart.Position, lookVector * (_G.shadowStepRange or 50), rayParams)
if ray then
    targetPos = ray.Position + (ray.Normal * 3)
end

task.spawn(function()
    EffectsModule.createShadowPortal(rootPart.Position)
    EffectsModule.createShadowStepTrail(rootPart.Position, targetPos)
end)

rootPart.CFrame = CFrame.new(targetPos, targetPos + lookVector)
FollowController:signalMovementOverride()

task.spawn(function()
    EffectsModule.createShadowPortal(targetPos)
end)

PlayerData.shadowStep.uses = PlayerData.shadowStep.uses + 1
local usesNeeded = PlayerData.shadowStep.level <= 10 and 5 or 8

if PlayerData.shadowStep.uses >= usesNeeded and PlayerData.shadowStep.level < 50 then
    PlayerData.shadowStep.level = PlayerData.shadowStep.level + 1
    PlayerData.shadowStep.uses = 0
    NotificationQueue:add({
        text = "SHADOW STEP LV UP",
        offset = Vector3.new(0, 3, 0),
        duration = 1.5,
        color = Color3.fromRGB(138, 43, 226)
    })
end

PlayerData.shadowStep.cooldown = _G.shadowStepMaxCooldown or 10
PlayerData.shadowStep.isActive = false
UIModule.updateAbilityButtons()
end
function AbilityModule.performDash()
if not rootPart or not humanoid then return end
local camera = workspace.CurrentCamera
local lookVector = camera.CFrame.LookVector
local bodyVelocity = Instance.new("BodyVelocity")
bodyVelocity.MaxForce = Vector3.new(4000, 0, 4000)
bodyVelocity.Velocity = lookVector * (_G.dashSpeed or 50)
bodyVelocity.Parent = rootPart

FollowController:signalMovementOverride()

Debris:AddItem(bodyVelocity, 0.3)
end
function AbilityModule.activateRampage()
if PlayerData.rampage.isActive
or PlayerData.rampage.cooldown > 0
or not PlayerData.rampage.unlocked
or not rootPart
or not AnimationLock:acquire("rampage", 7)
or not InputAuthority:canUseAbility()
then
return
end
InputAuthority:lockSystem(7)

task.spawn(function()
    EffectsModule.createRampageCutscene()
end)

task.wait(6.5)

PlayerData.rampage.isActive = true

local originalStats = {}
for stat, value in pairs(PlayerData.stats) do
    originalStats[stat] = value
    PlayerData.stats[stat] = Config.MAX_STAT_VALUE
end

humanoid.WalkSpeed = Config.MAX_WALK_SPEED
PlayerData.shadowStep.cooldown = 0

UIModule.updateAbilityButtons()

task.spawn(function()
    EffectsModule.createRampageAura()
end)

task.wait(PlayerData.rampage.duration)

PlayerData.rampage.isActive = false

for stat, value in pairs(originalStats) do
    PlayerData.stats[stat] = value
end

StatCalculator.applyStatEffects()

PlayerData.behindYou.cooldown = 0
PlayerData.rampage.cooldown = PlayerData.rampage.maxCooldown
PlayerData.rampage.currentKills = 0

UIModule.updateAbilityButtons()
end
function AbilityModule.performBehindYou()
if not PlayerData.rampage.isActive
or PlayerData.behindYou.cooldown > 0
or not rootPart
or not AnimationLock:acquire("behind_you", 1.5)
or not InputAuthority:canUseAbility()
then
return
end
InputAuthority:lockAbilities(1.5)

local nearestPlayer, nearestDistance = nil, math.huge

for _, otherPlayer in pairs(Players:GetPlayers()) do
    if otherPlayer ~= player and otherPlayer.Character then
        local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
        if otherRoot then
            local distance = (rootPart.Position - otherRoot.Position).Magnitude
            if distance >= Config.BEHIND_YOU_MIN_RANGE
                and distance <= Config.BEHIND_YOU_MAX_RANGE
                and distance < nearestDistance
            then
                nearestDistance = distance
                nearestPlayer = otherPlayer
            end
        end
    end
end

if not nearestPlayer then return end

local targetRoot = nearestPlayer.Character.HumanoidRootPart
local startPos = rootPart.Position
local targetPos = targetRoot.Position - (targetRoot.CFrame.LookVector * 5)

task.spawn(function()
    EffectsModule.createBehindYouEffect(startPos, targetPos)
end)

task.wait(0.15)

rootPart.CFrame = CFrame.new(targetPos, targetRoot.Position)
FollowController:signalMovementOverride()

PlayerData.behindYou.cooldown = PlayerData.behindYou.maxCooldown
UIModule.updateAbilityButtons()
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ–¥ï¸ UI MODULE (CONTINUED IN NEXT MESSAGE DUE TO LENGTH)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
UIModule = {}
local mainPart
local isVisible = false
local acceptedNotification = false
local levelValueLabel, xpBar, xpTextLabel, rankLabel, titleLabel, pointsValueLabel
local hpBar, hpTextLabel, shadowStepButton, cooldownBar, statsButton
local ssLevelLabel, classLabel, statusLabel, rampageButton, behindYouButton, rampageKillLabel
function UIModule.createRoundedFrame(parent, size, position, bgColor, transparency)
local frame = Instance.new("Frame")
frame.Size = size
frame.Position = position
frame.BackgroundColor3 = bgColor
frame.BackgroundTransparency = transparency or 0
frame.BorderSizePixel = 0
frame.Parent = parent
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 12)
corner.Parent = frame
return frame
end
function UIModule.createTextLabel(parent, text, size, position, textColor, fontSize, font, alignment)
local label = Instance.new("TextLabel")
label.Text = text
label.Size = size
label.Position = position
label.TextColor3 = textColor or Color3.fromRGB(255, 255, 255)
label.Font = font or Enum.Font.GothamBold
label.TextSize = fontSize or 24
label.BackgroundTransparency = 1
label.TextXAlignment = alignment or Enum.TextXAlignment.Left
label.TextYAlignment = Enum.TextYAlignment.Center
label.TextWrapped = true
label.Parent = parent
local stroke = Instance.new("UIStroke")
stroke.Thickness = 2
stroke.Color = Color3.fromRGB(0, 0, 0)
stroke.Transparency = 0.3
stroke.Parent = label
return label
end
function UIModule.createButton(parent, text, size, position, bgColor, textColor, fontSize, callback)
local button = Instance.new("TextButton")
button.Text = text
button.Size = size
button.Position = position
button.BackgroundColor3 = bgColor
button.TextColor3 = textColor
button.Font = Enum.Font.GothamBold
button.TextSize = fontSize
button.BorderSizePixel = 0
button.AutoButtonColor = false
button.Parent = parent
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = button
if callback then
    button.MouseButton1Click:Connect(callback)
    button.TouchTap:Connect(callback)
end

button.MouseEnter:Connect(function()
    TweenService:Create(button, TweenInfo.new(0.2), {
        BackgroundColor3 = Color3.new(
            math.min(bgColor.R + 0.2, 1),
            math.min(bgColor.G + 0.2, 1),
            math.min(bgColor.B + 0.2, 1)
        )
    }):Play()
end)

button.MouseLeave:Connect(function()
    TweenService:Create(button, TweenInfo.new(0.2), {
        BackgroundColor3 = bgColor
    }):Play()
end)

return button
end
function UIModule.updateUI()
    if not acceptedNotification then return end
    if levelValueLabel then
        levelValueLabel.Text = PlayerData.level .. "/" .. Config.LEVEL_CAP
    end
    
    if xpBar and xpTextLabel then
        local maxXP = LevelSystem.calculateRequiredXP(PlayerData.level)
        local progress = math.clamp(PlayerData.xp / maxXP, 0, 1)
        TweenService:Create(xpBar, TweenInfo.new(0.35), {
            Size = UDim2.new(progress, 0, 1, 0)
        }):Play()
        xpTextLabel.Text = "EXP: " .. PlayerData.xp .. "/" .. maxXP
    end
    
    if hpBar and hpTextLabel and humanoid then
        local hpPercent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
        TweenService:Create(hpBar, TweenInfo.new(0.2), {
            Size = UDim2.new(hpPercent, 0, 1, 0)
        }):Play()
        hpTextLabel.Text = math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth)
    end
    
    if pointsValueLabel then
        pointsValueLabel.Text = tostring(PlayerData.availablePoints)
    end
    
    local currentRank = LevelSystem.getCurrentRank()
    if rankLabel then
        rankLabel.Text = currentRank.name
        rankLabel.TextColor3 = currentRank.color
    end
    
    if titleLabel then titleLabel.Text = currentRank.title:upper() end
    if classLabel then classLabel.Text = LevelSystem.getCurrentClass():upper() end
    if statusLabel then statusLabel.Text = currentRank.status end
    if ssLevelLabel then ssLevelLabel.Text = "LV " .. PlayerData.shadowStep.level end
    
    if rampageKillLabel then
        if PlayerData.rampage.cooldown > 0 then
            rampageKillLabel.Text = string.format("KILLS: %d/%d", PlayerData.rampage.currentKills, PlayerData.rampage.killsRequired)
            rampageKillLabel.Visible = true
        else
            rampageKillLabel.Visible = false
        end
    end
end

function UIModule.updateAbilityButtons()
    if shadowStepButton and PlayerData.shadowStep.unlocked then
        shadowStepButton.Visible = true
        if PlayerData.shadowStep.cooldown > 0 then
            shadowStepButton.BackgroundColor3 = Color3.fromRGB(51, 51, 51)
            shadowStepButton.TextColor3 = Color3.fromRGB(150, 150, 150)
        else
            shadowStepButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            shadowStepButton.TextColor3 = Color3.fromRGB(138, 43, 226)
        end
        
        if cooldownBar then
            local progress = PlayerData.shadowStep.cooldown > 0
                and (1 - (PlayerData.shadowStep.cooldown / (_G.shadowStepMaxCooldown or 10)))
                or 1
            cooldownBar.Size = UDim2.new(progress, 0, 0, 4)
        end
    end
    
    if rampageButton and PlayerData.rampage.unlocked then
        rampageButton.Visible = true
        
        if PlayerData.rampage.cooldown > 0 or PlayerData.rampage.isActive then
            rampageButton.BackgroundColor3 = Color3.fromRGB(70, 0, 0)
            rampageButton.TextColor3 = Color3.fromRGB(150, 150, 150)
            rampageButton.Text = PlayerData.rampage.cooldown > 0
                and string.format("%.0fs", PlayerData.rampage.cooldown)
                or "ACTIVE"
        else
            rampageButton.BackgroundColor3 = Color3.fromRGB(139, 0, 0)
            rampageButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            rampageButton.Text = "RAGE"
        end
    end
    
    if behindYouButton then
        behindYouButton.Visible = PlayerData.rampage.isActive
        
        if PlayerData.behindYou.cooldown > 0 then
            behindYouButton.BackgroundColor3 = Color3.fromRGB(40, 0, 65)
            behindYouButton.TextColor3 = Color3.fromRGB(150, 150, 150)
        else
            behindYouButton.BackgroundColor3 = Color3.fromRGB(75, 0, 130)
            behindYouButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        end
    end
end

function UIModule.showStatDescription(statData)
    if not StateManager:canInteract() then
        return
    end
    if StateManager.activeDescription then
        UIModule.closeAllDescriptions()
        return
    end
    
    if not mainPart or not rootPart then return end
    if not AnimationLock:acquire("description", 0.5) then
        return
    end
    
    local descPart = Instance.new("Part")
    descPart.Name = "StatDescriptionPart"
    descPart.Size = Vector3.new(10, 7, 0.2)
    descPart.CFrame = mainPart.CFrame * CFrame.new(0, 0, 2)
    descPart.Anchored = true
    descPart.CanCollide = false
    descPart.Transparency = 0.05
    descPart.Material = Enum.Material.ForceField
    descPart.Parent = workspace
    
    FollowController:setDescriptionPart(descPart)
    
    local surfaceGui = Instance.new("SurfaceGui")
    surfaceGui.Face = Enum.NormalId.Front
    surfaceGui.CanvasSize = Vector2.new(1000, 700)
    surfaceGui.LightInfluence = 0
    surfaceGui.Brightness = 2
    surfaceGui.AlwaysOnTop = true
    surfaceGui.Parent = descPart
    
    local descFrame = UIModule.createRoundedFrame(
        surfaceGui,
        UDim2.new(0, 0, 0, 0),
        UDim2.new(0.5, 0, 0.5, 0),
        Color3.fromRGB(15, 20, 35),
        0
    )
    descFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    
    TweenService:Create(descFrame, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = UDim2.new(1, 0, 1, 0)
    }):Play()
    
    local frameStroke = Instance.new("UIStroke")
    frameStroke.Color = statData.color
    frameStroke.Thickness = 8
    frameStroke.Parent = descFrame
    
    local titleBar = UIModule.createRoundedFrame(
        descFrame,
        UDim2.new(1, 0, 0, 80),
        UDim2.new(0, 0, 0, 0),
        statData.color,
        0
    )
    
    UIModule.createTextLabel(
        titleBar,
        statData.title,
        UDim2.new(1, -20, 1, 0),
        UDim2.new(0, 10, 0, 0),
        Color3.fromRGB(255, 255, 255),
        32,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Center
    )
    
    local descText = UIModule.createTextLabel(
        descFrame,
        statData.description,
        UDim2.new(1, -60, 0, 450),
        UDim2.new(0, 30, 0, 100),
        Color3.fromRGB(220, 220, 220),
        22,
        Enum.Font.Gotham,
        Enum.TextXAlignment.Left
    )
    descText.TextYAlignment = Enum.TextYAlignment.Top
    
    UIModule.createButton(
        descFrame,
        "CLOSE",
        UDim2.new(0, 300, 0, 60),
        UDim2.new(0.5, -150, 1, -80),
        Color3.fromRGB(51, 65, 85),
        Color3.fromRGB(255, 255, 255),
        24,
        function()
            UIModule.closeAllDescriptions()
        end
    )
    
    StateManager.activeDescription = descPart
    
    task.delay(5, function()
        if StateManager.activeDescription == descPart then
            UIModule.closeAllDescriptions()
        end
    end)
end

function UIModule.closeAllDescriptions()
    if StateManager.activeDescription then
        local descToClose = StateManager.activeDescription
        local surfaceGui = descToClose:FindFirstChildOfClass("SurfaceGui")
        if surfaceGui then
            local frame = surfaceGui:FindFirstChild("Frame")
            if frame then
                TweenService:Create(frame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
                    Size = UDim2.new(0, 0, 0, 0)
                }):Play()
            end
        end
        
        TweenService:Create(descToClose, TweenInfo.new(0.3), {
            Transparency = 1
        }):Play()
        
        task.delay(0.3, function()
            if descToClose and descToClose.Parent then
                descToClose:Destroy()
            end
        end)
        
        StateManager.activeDescription = nil
        FollowController:setDescriptionPart(nil)
    end
end

function UIModule.createMainUI()
    local hrp = character:WaitForChild("HumanoidRootPart")
    mainPart = Instance.new("Part")
    mainPart.Name = "StatSystemObject"
    mainPart.Size = Vector3.new(14, 8, 0.2)
    
    local characterLook = hrp.CFrame.LookVector
    mainPart.CFrame = CFrame.new(hrp.Position + (characterLook * 8) + Vector3.new(0, 2, 0), hrp.Position)
    
    mainPart.Anchored = true
    mainPart.CanCollide = false
    mainPart.Transparency = 1
    mainPart.Material = Enum.Material.ForceField
    mainPart.Parent = workspace
    
    FollowController:initialize(mainPart)
    
    local surfaceGui = Instance.new("SurfaceGui")
    surfaceGui.Face = Enum.NormalId.Front
    surfaceGui.CanvasSize = Vector2.new(1400, 800)
    surfaceGui.LightInfluence = 0
    surfaceGui.Brightness = 2
    surfaceGui.Enabled = false
    surfaceGui.AlwaysOnTop = true
    surfaceGui.Parent = mainPart
    
    -- Create toggle buttons
    local playerGui = player:WaitForChild("PlayerGui")
    local toggleGui = Instance.new("ScreenGui")
    toggleGui.Name = "StatToggleGui"
    toggleGui.ResetOnSpawn = false
    toggleGui.Parent = playerGui
    
    local buttonContainer = Instance.new("Frame")
    buttonContainer.Size = UDim2.new(0, 65, 0, 225)
    buttonContainer.Position = UDim2.new(0, 20, 0.5, -112)
    buttonContainer.BackgroundTransparency = 1
    buttonContainer.Parent = toggleGui
    
    statsButton = UIModule.createButton(
        buttonContainer,
        "STATS",
        UDim2.new(0, 60, 0, 60),
        UDim2.new(0, 2, 0, 0),
        Color3.fromRGB(8, 145, 178),
        Color3.fromRGB(255, 255, 255),
        20,
        function()
            if AnimationLock:isLocked("ui_toggle") then return end
            if not InputAuthority:canInteractUI() then return end
            if not AnimationLock:acquire("ui_toggle", 0.8) then return end
            
            isVisible = not isVisible
            
            if isVisible then
                InputAuthority:lockUI(0.5)
                StateManager:setState("OPENING", 0.5)
                FollowController:forceResync()
                
                mainPart.Transparency = 0.05
                surfaceGui.Enabled = true
                local mainFrame = surfaceGui:FindFirstChild("MainFrame")
                if mainFrame then
                    mainFrame.Size = UDim2.new(1, 0, 0, 0)
                    TweenService:Create(mainFrame, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                        Size = UDim2.new(1, 0, 1, 0)
                    }):Play()
                end
                
                task.delay(0.5, function()
                    StateManager:setState("OPEN")
                end)
            else
                InputAuthority:lockUI(0.3)
                StateManager:setState("CLOSING", 0.3)
                UIModule.closeAllDescriptions()
                
                local mainFrame = surfaceGui:FindFirstChild("MainFrame")
                if mainFrame then
                    TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
                        Size = UDim2.new(1, 0, 0, 0)
                    }):Play()
                end
                
                task.delay(0.3, function()
                    surfaceGui.Enabled = false
                    mainPart.Transparency = 1
                    StateManager:setState("CLOSED")
                end)
            end
        end
    )
    
    local statsCorner = Instance.new("UICorner")
    statsCorner.CornerRadius = UDim.new(0, 10)
    statsCorner.Parent = statsButton
    
    shadowStepButton = UIModule.createButton(
        buttonContainer,
        "DASH",
        UDim2.new(0, 60, 0, 60),
        UDim2.new(0, 2, 0, 72),
        Color3.fromRGB(51, 51, 51),
        Color3.fromRGB(150, 150, 150),
        16,
        AbilityModule.performShadowStep
    )
    shadowStepButton.Visible = PlayerData.shadowStep.unlocked
    
    local shadowCorner = Instance.new("UICorner")
    shadowCorner.CornerRadius = UDim.new(0, 10)
    shadowCorner.Parent = shadowStepButton
    
    ssLevelLabel = UIModule.createTextLabel(
        shadowStepButton,
        "LV " .. PlayerData.shadowStep.level,
        UDim2.new(1, 0, 0, 18),
        UDim2.new(0, 0, 1, -20),
        Color3.fromRGB(138, 43, 226),
        11
    )
    ssLevelLabel.TextXAlignment = Enum.TextXAlignment.Center
    
    cooldownBar = Instance.new("Frame")
    cooldownBar.Size = UDim2.new(1, 0, 0, 4)
    cooldownBar.Position = UDim2.new(0, 0, 1, -4)
    cooldownBar.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
    cooldownBar.BorderSizePixel = 0
    cooldownBar.Parent = shadowStepButton
    
    rampageButton = UIModule.createButton(
        buttonContainer,
        "RAGE",
        UDim2.new(0, 60, 0, 60),
        UDim2.new(0, 2, 0, 144),
        Color3.fromRGB(139, 0, 0),
        Color3.fromRGB(255, 255, 255),
        18,
        AbilityModule.activateRampage
    )
    rampageButton.Visible = PlayerData.rampage.unlocked
    
    local rampageCorner = Instance.new("UICorner")
    rampageCorner.CornerRadius = UDim.new(0, 10)
    rampageCorner.Parent = rampageButton
    
    rampageKillLabel = UIModule.createTextLabel(
        rampageButton,
        string.format("%d/%d", PlayerData.rampage.currentKills, PlayerData.rampage.killsRequired),
        UDim2.new(1, 0, 0, 16),
        UDim2.new(0, 0, 1, -18),
        Color3.fromRGB(255, 215, 0),
        10
    )
    rampageKillLabel.TextXAlignment = Enum.TextXAlignment.Center
    rampageKillLabel.TextScaled = true
    rampageKillLabel.Visible = false
    
    behindYouButton = UIModule.createButton(
        buttonContainer,
        "BEHIND\nYOU",
        UDim2.new(0, 60, 0, 60),
        UDim2.new(1, -65, 0, 144),
        Color3.fromRGB(75, 0, 130),
        Color3.fromRGB(255, 255, 255),
        14,
        AbilityModule.performBehindYou
    )
    behindYouButton.Visible = false
    
    local behindCorner = Instance.new("UICorner")
    behindCorner.CornerRadius = UDim.new(0, 10)
    behindCorner.Parent = behindYouButton
    
    -- Create main UI frame
    local mainFrame = UIModule.createRoundedFrame(
        surfaceGui,
        UDim2.new(1, 0, 0, 0),
        UDim2.new(0, 0, 0, 0),
        Color3.fromRGB(10, 15, 30),
        0
    )
    mainFrame.Name = "MainFrame"
    
    local mainStroke = Instance.new("UIStroke")
    mainStroke.Color = Color3.fromRGB(6, 182, 212)
    mainStroke.Thickness = 10
    mainStroke.Parent = mainFrame
    
    local titleSection = UIModule.createRoundedFrame(
        mainFrame,
        UDim2.new(1, 0, 0, 80),
        UDim2.new(0, 0, 0, 0),
        Color3.fromRGB(15, 20, 35),
        0
    )
    
    UIModule.createTextLabel(
        titleSection,
        "SYSTEM",
        UDim2.new(1, -40, 1, 0),
        UDim2.new(0, 20, 0, 0),
        Color3.fromRGB(6, 182, 212),
        42,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Center
    )
    
    -- HP Section
    local hpSection = Instance.new("Frame")
    hpSection.Size = UDim2.new(1, -60, 0, 60)
    hpSection.Position = UDim2.new(0, 30, 0, 95)
    hpSection.BackgroundTransparency = 1
    hpSection.Parent = mainFrame
    
    UIModule.createTextLabel(
        hpSection,
        "HP",
        UDim2.new(0, 60, 0, 32),
        UDim2.new(0, 0, 0, 14),
        Color3.fromRGB(239, 68, 68),
        28
    )
    
    local hpBarBg = UIModule.createRoundedFrame(
        hpSection,
        UDim2.new(0, 900, 0, 32),
        UDim2.new(0, 70, 0, 14),
        Color3.fromRGB(20, 25, 40),
        0
    )
    
    local hpBorder = Instance.new("UIStroke")
    hpBorder.Color = Color3.fromRGB(239, 68, 68)
    hpBorder.Thickness = 3
    hpBorder.Parent = hpBarBg
    
    hpBar = UIModule.createRoundedFrame(
        hpBarBg,
        UDim2.new(1, 0, 1, 0),
        UDim2.new(0, 0, 0, 0),
        Color3.fromRGB(220, 38, 38),
        0
    )
    
    hpTextLabel = UIModule.createTextLabel(
        hpBar,
        math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth),
        UDim2.new(1, -15, 1, 0),
        UDim2.new(0, 0, 0, 0),
        Color3.fromRGB(255, 255, 255),
        22,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Right
    )
    
    UIModule.createTextLabel(
        hpSection,
        "LV",
        UDim2.new(0, 50, 0, 32),
        UDim2.new(1, -180, 0, 14),
        Color3.fromRGB(150, 150, 150),
        24
    )
    
    levelValueLabel = UIModule.createTextLabel(
        hpSection,
        PlayerData.level .. "/" .. Config.LEVEL_CAP,
        UDim2.new(0, 125, 0, 32),
        UDim2.new(1, -125, 0, 14),
        Color3.fromRGB(255, 255, 255),
        24
    )
    
    -- XP Bar
    local xpBarBg = UIModule.createRoundedFrame(
        mainFrame,
        UDim2.new(1, -60, 0, 22),
        UDim2.new(0, 30, 0, 167),
        Color3.fromRGB(20, 25, 40),
        0
    )
    
    local xpBorder = Instance.new("UIStroke")
    xpBorder.Color = Color3.fromRGB(34, 211, 238)
    xpBorder.Thickness = 3
    xpBorder.Parent = xpBarBg
    
    xpBar = UIModule.createRoundedFrame(
        xpBarBg,
        UDim2.new(PlayerData.xp / LevelSystem.calculateRequiredXP(PlayerData.level), 0, 1, 0),
        UDim2.new(0, 0, 0, 0),
        Color3.fromRGB(34, 211, 238),
        0
    )
    
    xpTextLabel = UIModule.createTextLabel(
        xpBarBg,
        "EXP: " .. PlayerData.xp .. "/" .. LevelSystem.calculateRequiredXP(PlayerData.level),
        UDim2.new(1, -12, 1, 0),
        UDim2.new(0, 12, 0, 0),
        Color3.fromRGB(255, 255, 255),
        18,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Left
    )
    
    -- Stats Container
    local statsContainer = Instance.new("Frame")
    statsContainer.Size = UDim2.new(1, -60, 0, 320)
    statsContainer.Position = UDim2.new(0, 30, 0, 205)
    statsContainer.BackgroundTransparency = 1
    statsContainer.Parent = mainFrame
    
    local function createStatRow(statKey, yPos, xPos)
        local stat = StatInfo[statKey]
        local statFrame = UIModule.createRoundedFrame(
            statsContainer,
            UDim2.new(0, 650, 0, 85),
            UDim2.new(0, xPos, 0, yPos),
            Color3.fromRGB(20, 25, 40),
            0
        )
        
        local statBorder = Instance.new("UIStroke")
        statBorder.Color = stat.color
        statBorder.Thickness = 3
        statBorder.Parent = statFrame
        
        local abbrBox = UIModule.createRoundedFrame(
            statFrame,
            UDim2.new(0, 90, 0, 55),
            UDim2.new(0, 15, 0, 15),
            Color3.fromRGB(15, 20, 35),
            0
        )
        
        local abbrBorder = Instance.new("UIStroke")
        abbrBorder.Color = stat.color
        abbrBorder.Thickness = 3
        abbrBorder.Parent = abbrBox
        
        UIModule.createTextLabel(
            abbrBox,
            stat.abbr,
            UDim2.new(1, 0, 1, 0),
            UDim2.new(0, 0, 0, 0),
            stat.color,
            26,
            Enum.Font.GothamBold,
            Enum.TextXAlignment.Center
        )
        
        UIModule.createTextLabel(
            statFrame,
            stat.name,
            UDim2.new(0, 180, 0, 40),
            UDim2.new(0, 115, 0, 22),
            Color3.fromRGB(220, 220, 220),
            24
        )
        
        local valueLabel = UIModule.createTextLabel(
            statFrame,
            tostring(PlayerData.stats[statKey]),
            UDim2.new(0, 65, 0, 40),
            UDim2.new(0, 300, 0, 22),
            Color3.fromRGB(255, 255, 255),
            32,
            Enum.Font.GothamBold,
            Enum.TextXAlignment.Center
        )
        
        local effectLabel = UIModule.createTextLabel(
            statFrame,
            stat.getEffect(PlayerData.stats[statKey]),
            UDim2.new(0, 160, 0, 26),
            UDim2.new(0, 375, 0, 29),
            stat.color,
            18,
            Enum.Font.Gotham,
            Enum.TextXAlignment.Left
        )
        
        UIModule.createButton(
            statFrame,
            "?",
            UDim2.new(0, 35, 0, 35),
            UDim2.new(0, 540, 0, 25),
            Color3.fromRGB(30, 35, 50),
            Color3.fromRGB(200, 200, 200),
     22,
            function()
                UIModule.showStatDescription(stat)
            end
        )
        
        UIModule.createButton(
            statFrame,
            "+",
            UDim2.new(0, 45, 0, 45),
            UDim2.new(0, 585, 0, 20),
            Color3.fromRGB(51, 65, 85),
            stat.color,
            30,
            function()
                if PlayerData.availablePoints > 0 and PlayerData.stats[statKey] < Config.MAX_STAT_VALUE then
                    PlayerData.stats[statKey] = math.min(PlayerData.stats[statKey] + 1, Config.MAX_STAT_VALUE)
                    PlayerData.availablePoints = PlayerData.availablePoints - 1
                    
                    StatCalculator.applyStatEffects()
                    task.spawn(function()
                        EffectsModule.createStatUpgradeEffect(statKey)
                    end)
                    
                    valueLabel.Text = tostring(PlayerData.stats[statKey])
                    effectLabel.Text = stat.getEffect(PlayerData.stats[statKey])
                    UIModule.updateUI()
                end
            end
        )
    end
    
    createStatRow("strength", 0, 0)
    createStatRow("agility", 95, 0)
    createStatRow("perception", 190, 0)
    createStatRow("vitality", 0, 700)
    createStatRow("intelligence", 95, 700)
    
    -- Points Box
    local pointsBox = UIModule.createRoundedFrame(
        statsContainer,
        UDim2.new(0, 650, 0, 75),
        UDim2.new(0, 700, 0, 200),
        Color3.fromRGB(20, 30, 50),
        0
    )
    
    local pointsStroke = Instance.new("UIStroke")
    pointsStroke.Color = Color3.fromRGB(34, 211, 238)
    pointsStroke.Thickness = 5
    pointsStroke.Parent = pointsBox
    
    UIModule.createTextLabel(
        pointsBox,
        "Available Points",
        UDim2.new(0, 380, 1, 0),
        UDim2.new(0, 30, 0, 0),
        Color3.fromRGB(220, 220, 220),
        26
    )
    
    pointsValueLabel = UIModule.createTextLabel(
        pointsBox,
        tostring(PlayerData.availablePoints),
        UDim2.new(0, 220, 1, 0),
        UDim2.new(1, -240, 0, 0),
        Color3.fromRGB(34, 211, 238),
        38,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Center
    )
    
    -- Info Container
    local infoContainer = Instance.new("Frame")
    infoContainer.Size = UDim2.new(1, -60, 0, 160)
    infoContainer.Position = UDim2.new(0, 30, 0, 540)
    infoContainer.BackgroundTransparency = 1
    infoContainer.Parent = mainFrame
    
    local function createInfoRow(label, value, xPos, yPos, valueColor)
        UIModule.createTextLabel(
            infoContainer,
            label,
            UDim2.new(0, 160, 0, 50),
            UDim2.new(0, xPos, 0, yPos),
            Color3.fromRGB(160, 160, 160),
            24
        )
        
        local valueText = UIModule.createTextLabel(
            infoContainer,
            value,
            UDim2.new(0, 470, 0, 50),
UDim2.new(0, xPos + 165, 0, yPos),
valueColor,
26,
Enum.Font.GothamBold,
Enum.TextXAlignment.Right
)
valueText.TextScaled = true
return valueText
end
local currentRank = LevelSystem.getCurrentRank()
rankLabel = createInfoRow("RANK", currentRank.name, 0, 10, currentRank.color)
classLabel = createInfoRow("CLASS", LevelSystem.getCurrentClass():upper(), 0, 58, Color3.fromRGB(168, 85, 247))
titleLabel = createInfoRow("TITLE", currentRank.title:upper(), 680, 10, Color3.fromRGB(248, 113, 113))
statusLabel = createInfoRow("STATUS", currentRank.status, 680, 58, Color3.fromRGB(34, 211, 238))

UIModule.updateUI()
end
function UIModule.createInitialNotification()
local notifPart = Instance.new("Part")
notifPart.Name = "NotificationPart"
notifPart.Size = Vector3.new(12, 7, 0.2)
local characterLook = rootPart.CFrame.LookVector
notifPart.CFrame = CFrame.new(rootPart.Position + (characterLook * 8) + Vector3.new(0, 3, 0), rootPart.Position)

notifPart.Anchored = true
notifPart.CanCollide = false
notifPart.Transparency = 0.05
notifPart.Material = Enum.Material.ForceField
notifPart.Parent = workspace

local surfaceGui = Instance.new("SurfaceGui")
surfaceGui.Face = Enum.NormalId.Front
surfaceGui.CanvasSize = Vector2.new(1200, 700)
surfaceGui.LightInfluence = 0
surfaceGui.Brightness = 2
surfaceGui.AlwaysOnTop = true
surfaceGui.Parent = notifPart

local bg = UIModule.createRoundedFrame(
    surfaceGui,
    UDim2.new(1, 0, 1, 0),
    UDim2.new(0, 0, 0, 0),
    Color3.fromRGB(10, 15, 30),
    0
)

local stroke = Instance.new("UIStroke")
stroke.Color = Color3.fromRGB(6, 182, 212)
stroke.Thickness = 10
stroke.Parent = bg

UIModule.createTextLabel(
    bg,
    "SYSTEM NOTIFICATION",
    UDim2.new(1, -40, 0, 90),
    UDim2.new(0, 20, 0, 35),
    Color3.fromRGB(6, 182, 212),
    44,
    Enum.Font.GothamBold,
    Enum.TextXAlignment.Center
)

UIModule.createTextLabel(
    bg,
    "You have acquired the qualifications\nto become a Player.\n\nThe System has recognized your potential.\nWill you accept this power?",
    UDim2.new(1, -80, 0, 180),
    UDim2.new(0, 40, 0, 145),
    Color3.fromRGB(220, 220, 220),
    26,
    Enum.Font.Gotham,
    Enum.TextXAlignment.Center
)

UIModule.createButton(
    bg,
    "ACCEPT",
    UDim2.new(0, 380, 0, 90),
    UDim2.new(0, 80, 1, -130),
    Color3.fromRGB(8, 145, 178),
    Color3.fromRGB(255, 255, 255),
    32,
    function()
        acceptedNotification = true
        TweenService:Create(notifPart, TweenInfo.new(0.3), {Transparency = 1}):Play()
        task.wait(0.3)
        notifPart:Destroy()
        UIModule.createMainUI()
    end
)

UIModule.createButton(
    bg,
    "DECLINE",
    UDim2.new(0, 380, 0, 90),
    UDim2.new(1, -460, 1, -130),
    Color3.fromRGB(51, 65, 85),
    Color3.fromRGB(255, 255, 255),
    32,
    function()
        acceptedNotification = false
        TweenService:Create(notifPart, TweenInfo.new(0.3), {Transparency = 1}):Play()
        task.wait(0.3)
        notifPart:Destroy()
    end
)

-- Follow character smoothly
task.spawn(function()
    local t = 0
    while notifPart and notifPart.Parent do
        t = t + task.wait(0.05)
        local bobY = math.sin(t * 2) * 0.3
        
        if character and character:FindFirstChild("HumanoidRootPart") then
            local hrp = character.HumanoidRootPart
            local charLook = hrp.CFrame.LookVector
            local targetPos = hrp.Position + (charLook * 8) + Vector3.new(0, 3 + bobY, 0)
            local lookAtPos = Vector3.new(hrp.Position.X, notifPart.Position.Y, hrp.Position.Z)
            notifPart.CFrame = notifPart.CFrame:Lerp(CFrame.new(targetPos, lookAtPos), 0.12)
        end
    end
end)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ® PLAYER MONITORING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function monitorPlayers()
pcall(function()
for _, otherPlayer in pairs(Players:GetPlayers()) do
if otherPlayer ~= player and otherPlayer.Character then
CombatModule.setupHealthMonitoring(otherPlayer)
end
end
end)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ”„ UNIFIED UPDATE LOOP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function startUnifiedUpdateLoop()
local accumulators = {ui = 0, regen = 0, cleanup = 0, monitor = 0}
local updateInterval = PhoneOptimizer:getUpdateInterval()
RunService.Heartbeat:Connect(function(deltaTime)
    pcall(function()
        accumulators.ui = accumulators.ui + deltaTime
        if accumulators.ui >= updateInterval then
            accumulators.ui = 0
            
            local shouldUpdateUI = acceptedNotification and (isVisible or PlayerData.shadowStep.cooldown > 0 or PlayerData.rampage.cooldown > 0)
            
            if PlayerData.shadowStep.cooldown > 0 then
                PlayerData.shadowStep.cooldown = math.max(0, PlayerData.shadowStep.cooldown - updateInterval)
                if shouldUpdateUI then
                    UIModule.updateAbilityButtons()
                end
            end
            
            if PlayerData.rampage.cooldown > 0 then
                PlayerData.rampage.cooldown = math.max(0, PlayerData.rampage.cooldown - updateInterval)
                if shouldUpdateUI then
                    UIModule.updateAbilityButtons()
                end
            end
            
            if PlayerData.behindYou.cooldown > 0 then
                PlayerData.behindYou.cooldown = math.max(0, PlayerData.behindYou.cooldown - updateInterval)
                if shouldUpdateUI then
                    UIModule.updateAbilityButtons()
                end
            end
        end
        
        accumulators.regen = accumulators.regen + deltaTime
        if accumulators.regen >= 1 then
            accumulators.regen = 0
            if humanoid and humanoid.Health > 0 and humanoid.Health < humanoid.MaxHealth then
                local regenAmount = PlayerData.stats.vitality * Config.STAT_CURVES.vitality.regenPerPoint
                if regenAmount > 0 then
                    humanoid.Health = math.min(humanoid.Health + regenAmount, humanoid.MaxHealth)
                    if isVisible then
                        UIModule.updateUI()
                    end
                end
            end
        end
        
        accumulators.cleanup = accumulators.cleanup + deltaTime
        if accumulators.cleanup >= 5 then
            accumulators.cleanup = 0
            local currentTime = tick()
            
            for userId, engagement in pairs(PlayerData.combatEngagement) do
                if currentTime - engagement.lastHit > Config.COMBAT_TIMEOUT then
                    PlayerData.combatEngagement[userId] = nil
                end
            end
            
            for userId, assist in pairs(PlayerData.assistEngagement) do
                if currentTime - assist.lastSeen > Config.ASSIST_TIME_WINDOW then
                    PlayerData.assistEngagement[userId] = nil
                end
            end
        end
        
        accumulators.monitor = accumulators.monitor + deltaTime
        if accumulators.monitor >= 2 then
            accumulators.monitor = 0
            monitorPlayers()
        end
    end)
end)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ›¡ï¸ SECOND CHANCE SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function setupSecondChance()
if not humanoid then return end
humanoid.Died:Connect(function()
if PlayerData.hasSecondChance and PlayerData.stats.vitality >= Config.STAT_CURVES.vitality.secondChanceThreshold then
task.wait(0.1)
if humanoid and humanoid.Health <= 0 then
humanoid.Health = PlayerData.maxHP * 0.5
PlayerData.hasSecondChance = false
task.spawn(function()
                EffectsModule.createSecondChanceEffect()
                NotificationQueue:add({
                    text = "SECOND CHANCE",
                    offset = Vector3.new(0, 3, 0),
                    duration = 1.5,
                    color = Color3.fromRGB(168, 85, 247)
                })
            end)
            
            task.wait(60)
            PlayerData.hasSecondChance = true
            if PlayerData.stats.vitality >= Config.STAT_CURVES.vitality.secondChanceThreshold then
                NotificationQueue:add({
                    text = "SECOND CHANCE READY",
                    offset = Vector3.new(0, 3, 0),
                    duration = 1.5,
                    color = Color3.fromRGB(168, 85, 247)
                })
            end
        end
    end
end)

humanoid.HealthChanged:Connect(function()
    if isVisible then
        UIModule.updateUI()
    end
end)

humanoid:GetPropertyChangedSignal("MaxHealth"):Connect(function()
    if isVisible then
        UIModule.updateUI()
    end
end)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âŒ¨ï¸ INPUT HANDLING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function setupInputHandling()
UserInputService.InputBegan:Connect(function(input, gameProcessed)
if gameProcessed then return end
if not InputAuthority:canUseAbility() then return end
if input.KeyCode == Enum.KeyCode.E then
        AbilityModule.performShadowStep()
    end
    
    if input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.RightShift then
        AbilityModule.performDash()
    end
    
    if input.KeyCode == Enum.KeyCode.R then
        AbilityModule.activateRampage()
    end
    
    if input.KeyCode == Enum.KeyCode.F then
        AbilityModule.performBehindYou()
    end
end)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ”„ CHARACTER RESPAWN HANDLING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
player.CharacterAdded:Connect(function(newCharacter)
character = newCharacter
humanoid = newCharacter:WaitForChild("Humanoid")
rootPart = newCharacter:WaitForChild("HumanoidRootPart")
humanoid.MaxHealth = PlayerData.maxHP
humanoid.Health = PlayerData.maxHP
if PlayerData.stats.vitality >= Config.STAT_CURVES.vitality.secondChanceThreshold then
    PlayerData.hasSecondChance = true
end

task.wait(0.2)
StatCalculator.applyStatEffects()
UIModule.updateUI()

if acceptedNotification and mainPart then
    task.wait(0.5)
    FollowController:forceResync()
end

setupSecondChance()
end)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸš€ INITIALIZATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function initialize()
pcall(function()
StatCalculator.applyStatEffects()
if humanoid then
humanoid.MaxHealth = PlayerData.maxHP
humanoid.Health = PlayerData.maxHP
end
setupInputHandling()
setupSecondChance()
task.defer(function()
        startUnifiedUpdateLoop()
        monitorPlayers()
        
        Players.PlayerAdded:Connect(function()
            task.wait(1)
            monitorPlayers()
        end)
    end)
    
    task.wait(0.5)
    UIModule.createInitialNotification()
    
    -- Print ability info to console for system reference
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("SOLO LEVELING SYSTEM INITIALIZED")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    for abilityName, _ in pairs(AbilityCodex) do
        if abilityName ~= "getAbilityInfo" then
            local info = AbilityCodex:getAbilityInfo(abilityName, PlayerData)
            if info then
                print("\n" .. info.name .. " (" .. info.category .. ")")
                print("Unlock Level: " .. info.unlockLevel)
                print(info.description)
                print("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
            end
        end
    end
end)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- â–¶ï¸ START SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
initialize()
