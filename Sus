-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âš¡ SOLO LEVELING SYSTEM - ULTIMATE COMPLETE VERSION
-- Production Ready | All Systems Operational | Enhanced Edition
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ”’ GLOBAL INPUT AUTHORITY
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local InputAuthority = {
    systemBusy = false,
    abilityActive = false,
    uiAnimating = false
}

function InputAuthority:canUseAbility()
    return not (self.systemBusy or self.abilityActive or self.uiAnimating)
end

function InputAuthority:canInteractUI()
    return not (self.systemBusy or self.uiAnimating)
end

function InputAuthority:lockAbilities(duration)
    self.abilityActive = true
    if duration then
        task.delay(duration, function()
            self.abilityActive = false
        end)
    end
end

function InputAuthority:lockUI(duration)
    self.uiAnimating = true
    task.delay(duration, function()
        self.uiAnimating = false
    end)
end

function InputAuthority:lockSystem(duration)
    self.systemBusy = true
    task.delay(duration, function()
        self.systemBusy = false
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ® CORE CONFIGURATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Config = {
    BASE_WALK_SPEED = 16,
    MAX_WALK_SPEED = 100,
    BASE_DASH_SPEED = 50,
    BASE_DASH_RANGE = 30,
    BASE_SHADOW_STEP_RANGE = 50,
    BASE_SHADOW_STEP_COOLDOWN = 10,
    LEVEL_CAP = 100,
    MAX_STAT_VALUE = 100,
    POINTS_PER_LEVEL = 3,
    SHADOW_STEP_UNLOCK_LEVEL = 10,
    RAMPAGE_UNLOCK_LEVEL = 25,
    COMBAT_TIMEOUT = 5,
    MIN_DAMAGE_FOR_CREDIT = 50,
    ASSIST_RANGE = 50,
    ASSIST_TIME_WINDOW = 10,
    BASE_KILL_XP = 200,
    ASSIST_XP_MULTIPLIER = 0.3,
    BEHIND_YOU_MIN_RANGE = 100,
    BEHIND_YOU_MAX_RANGE = 500,
    VFX = {
        SHADOW_PORTAL_PARTICLES = 15,
        LEVEL_UP_PARTICLES = 40,
        STAT_UPGRADE_ORBS = 8,
        RAMPAGE_AURA_DENSITY = 25,
        BEHIND_YOU_SMOKE = 15
    },
    STAT_CURVES = {
        strength = {damagePerPoint = 2, diminishingStart = 50, diminishingFactor = 0.8},
        agility = {walkSpeedPerPoint = 0.84, dashSpeedPerPoint = 0.04},
        perception = {
            rangePerPoint = 10,
            dashRangePerPoint = 0.05,
            cooldownReductionPerPoint = 0.02,
            maxCooldownReduction = 0.6,
            rampageDurationPerPoint = 2.1,
            behindYouCDReductionPerPoint = 0.15,
            killDetectionBonus = 0.05
        },
        vitality = {hpPerPoint = 20, regenPerPoint = 0.5, secondChanceThreshold = 10},
        intelligence = {xpPerPoint = 50, cooldownBonusPerPoint = 0.01}
    }
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“± MOBILE OPTIMIZER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local PhoneOptimizer = {
    isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
}

function PhoneOptimizer:getUpdateInterval()
    return self.isMobile and 0.15 or 0.1
end

function PhoneOptimizer:getVFXMultiplier()
    return self.isMobile and 0.65 or 1.0
end

if PhoneOptimizer.isMobile then
    local m = PhoneOptimizer:getVFXMultiplier()
    Config.VFX.SHADOW_PORTAL_PARTICLES = math.floor(Config.VFX.SHADOW_PORTAL_PARTICLES * m)
    Config.VFX.LEVEL_UP_PARTICLES = math.floor(Config.VFX.LEVEL_UP_PARTICLES * m)
    Config.VFX.RAMPAGE_AURA_DENSITY = math.floor(Config.VFX.RAMPAGE_AURA_DENSITY * m)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ’¾ ENHANCED DATA PERSISTENCE (CODEX WORKSHOP FILE)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local DataModule = {}
local SAVE_FILE = "CodexWorkshop_SoloLeveling_" .. player.UserId .. ".json"
local BACKUP_FILE = "CodexWorkshop_SoloLeveling_" .. player.UserId .. "_backup.json"

function DataModule.savePlayerData(data)
    pcall(function()
        local saveData = {
            -- Player Stats
            stats = {
                strength = data.stats.strength,
                agility = data.stats.agility,
                perception = data.stats.perception,
                vitality = data.stats.vitality,
                intelligence = data.stats.intelligence
            },
            
            -- Level & XP
            level = data.level,
            xp = data.xp,
            availablePoints = data.availablePoints,
            
            -- Health
            maxHP = data.maxHP,
            
            -- Shadow Step Progress
            shadowStep = {
                level = data.shadowStep.level,
                uses = data.shadowStep.uses,
                unlocked = data.shadowStep.unlocked
            },
            
            -- Rampage Progress
            rampage = {
                unlocked = data.rampage.unlocked,
                currentKills = data.rampage.currentKills
            },
            
            -- System Metadata
            metadata = {
                version = "2.0",
                lastSave = os.time(),
                playerName = player.Name,
                playerId = player.UserId
            }
        }
        
        local json = HttpService:JSONEncode(saveData)
        
        -- Save to main file
        if writefile then
            -- Create backup of previous save
            if isfile and isfile(SAVE_FILE) then
                local oldData = readfile(SAVE_FILE)
                writefile(BACKUP_FILE, oldData)
            end
            
            writefile(SAVE_FILE, json)
            print("âœ… Data saved to Codex Workshop file: " .. SAVE_FILE)
        end
    end)
end

function DataModule.loadPlayerData()
    local success, data = pcall(function()
        if isfile and isfile(SAVE_FILE) then
            local json = readfile(SAVE_FILE)
            local decoded = HttpService:JSONDecode(json)
            
            -- Validate data integrity
            if decoded.metadata and decoded.metadata.playerId == player.UserId then
                print("âœ… Loaded save data from Codex Workshop file")
                print("ğŸ“Š Last save: " .. os.date("%Y-%m-%d %H:%M:%S", decoded.metadata.lastSave))
                return decoded
            end
        elseif isfile and isfile(BACKUP_FILE) then
            -- Try loading backup
            print("âš ï¸ Main save corrupted, loading backup...")
            local json = readfile(BACKUP_FILE)
            return HttpService:JSONDecode(json)
        end
        return nil
    end)
    
    return success and data or nil
end

function DataModule.exportData()
    -- Export full readable data log
    local exportFile = "CodexWorkshop_SoloLeveling_Export_" .. os.time() .. ".txt"
    local data = PlayerData
    
    local exportText = string.format([[
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CODEX WORKSHOP - SOLO LEVELING SYSTEM DATA EXPORT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Player: %s (ID: %d)
Export Date: %s

LEVEL INFORMATION:
â”œâ”€ Current Level: %d / %d
â”œâ”€ Experience: %d / %d
â””â”€ Available Points: %d

STATS:
â”œâ”€ Strength: %d
â”œâ”€ Agility: %d
â”œâ”€ Perception: %d
â”œâ”€ Vitality: %d
â””â”€ Intelligence: %d

ABILITIES:
â”œâ”€ Shadow Step
â”‚  â”œâ”€ Unlocked: %s
â”‚  â”œâ”€ Level: %d / 50
â”‚  â””â”€ Uses: %d
â”‚
â”œâ”€ Rampage
â”‚  â”œâ”€ Unlocked: %s
â”‚  â””â”€ Kills to Recharge: %d / 5
â”‚
â””â”€ Behind You (Rampage-Only)
   â””â”€ Available during Rampage

HEALTH:
â”œâ”€ Max HP: %d
â””â”€ Second Chance: %s

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
]],
        player.Name,
        player.UserId,
        os.date("%Y-%m-%d %H:%M:%S"),
        data.level,
        Config.LEVEL_CAP,
        data.xp,
        LevelSystem.calculateRequiredXP(data.level),
        data.availablePoints,
        data.stats.strength,
        data.stats.agility,
        data.stats.perception,
        data.stats.vitality,
        data.stats.intelligence,
        data.shadowStep.unlocked and "Yes" or "No",
        data.shadowStep.level,
        data.shadowStep.uses,
        data.rampage.unlocked and "Yes" or "No",
        data.rampage.currentKills,
        data.maxHP,
        data.hasSecondChance and "Ready" or "Used"
    )
    
    if writefile then
        writefile(exportFile, exportText)
        print("âœ… Data exported to: " .. exportFile)
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ¯ STATE MANAGER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local StateManager = {
    current = "CLOSED",
    canTransition = true,
    activeDescription = nil,
    systemLocked = false
}

function StateManager:setState(newState, lockDuration)
    if self.systemLocked then return false end
    
    local validTransitions = {
        CLOSED = {"OPENING", "LOCKED"},
        OPENING = {"OPEN", "CLOSING"},
        OPEN = {"CLOSING", "LOCKED"},
        CLOSING = {"CLOSED"},
        LOCKED = {"OPENING", "CLOSED", "OPEN"}
    }
    
    if not table.find(validTransitions[self.current] or {}, newState) then
        return false
    end
    
    self.current = newState
    
    if lockDuration then
        self.canTransition = false
        task.delay(lockDuration, function()
            self.canTransition = true
        end)
    end
    
    return true
end

function StateManager:canInteract()
    return self.current == "OPEN" and self.canTransition and not self.systemLocked
end

function StateManager:lock(duration)
    self.systemLocked = true
    if duration then
        task.delay(duration, function()
            self.systemLocked = false
        end)
    end
end

function StateManager:unlock()
    self.systemLocked = false
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ¬ ANIMATION LOCK
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local AnimationLock = {
    locks = {}
}

function AnimationLock:acquire(key, duration)
    if self.locks[key] then return false end
    self.locks[key] = true
    task.delay(duration, function()
        self.locks[key] = nil
    end)
    return true
end

function AnimationLock:isLocked(key)
    return self.locks[key] == true
end

function AnimationLock:release(key)
    self.locks[key] = nil
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“¢ NOTIFICATION QUEUE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local NotificationQueue = {
    queue = {},
    isPlaying = false,
    isPaused = false
}

function NotificationQueue:add(notification)
    table.insert(self.queue, notification)
    if not self.isPlaying then
        self:playNext()
    end
end

function NotificationQueue:playNext()
    if #self.queue == 0 then
        self.isPlaying = false
        return
    end
    
    if self.isPaused then return end
    
    self.isPlaying = true
    local notif = table.remove(self.queue, 1)
    
    task.spawn(function()
        self:spawnNotification(notif)
        task.wait(notif.duration or 1.5)
        self:playNext()
    end)
end

function NotificationQueue:spawnNotification(notif)
    if not rootPart then return end
    
    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(1, 1, 1)
    part.CFrame = rootPart.CFrame * CFrame.new(notif.offset)
    part.Parent = workspace

    local gui = Instance.new("BillboardGui")
    gui.Size = UDim2.new(0, 300, 0, 100)
    gui.AlwaysOnTop = true
    gui.StudsOffset = Vector3.new(0, 0, 0)
    gui.Parent = part

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = notif.text
    label.Font = Enum.Font.GothamBlack
    label.TextScaled = true
    label.TextColor3 = notif.color or Color3.fromRGB(255, 60, 60)
    label.TextStrokeTransparency = 0
    label.TextStrokeColor3 = Color3.new(0, 0, 0)
    label.Parent = gui

    TweenService:Create(part, TweenInfo.new(notif.duration or 1.5), {
        CFrame = part.CFrame * CFrame.new(0, 5, 0)
    }):Play()
    TweenService:Create(label, TweenInfo.new(notif.duration or 1.5), {
        TextTransparency = 1,
        TextStrokeTransparency = 1
    }):Play()

    Debris:AddItem(part, (notif.duration or 1.5) + 0.1)
end

function NotificationQueue:pause()
    self.isPaused = true
end

function NotificationQueue:resume()
    self.isPaused = false
    if not self.isPlaying and #self.queue > 0 then
        self:playNext()
    end
end

function NotificationQueue:clear()
    self.queue = {}
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ¯ FOLLOW CONTROLLER (FIXED)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local FollowController = {
    mainPart = nil,
    descriptionPart = nil,
    lastKnownCFrame = nil,
    teleportThreshold = 50,
    updateConnection = nil,
    isPaused = false,
    needsResync = false,
    dashCooldown = 0
}

function FollowController:initialize(part)
    self.mainPart = part
    self.lastKnownCFrame = rootPart.CFrame
    self:startFollowing()
end

function FollowController:setDescriptionPart(part)
    self.descriptionPart = part
end

function FollowController:detectTeleport()
    if not self.lastKnownCFrame or not rootPart then return false end
    
    local distance = (rootPart.CFrame.Position - self.lastKnownCFrame.Position).Magnitude
    self.lastKnownCFrame = rootPart.CFrame
    
    return distance > self.teleportThreshold
end

function FollowController:signalMovementOverride()
    self.needsResync = true
    self.isPaused = true
    self.dashCooldown = 0.5
    task.delay(0.5, function()
        self.isPaused = false
        self:forceResync()
    end)
end

function FollowController:forceResync()
    if not rootPart or not self.mainPart then return end
    
    local characterLook = rootPart.CFrame.LookVector
    local targetPos = rootPart.Position + (characterLook * 8) + Vector3.new(0, 2, 0)
    local lookAtPos = Vector3.new(rootPart.Position.X, self.mainPart.Position.Y, rootPart.Position.Z)
    
    self.mainPart.CFrame = CFrame.new(targetPos, lookAtPos)
    
    if self.descriptionPart and self.descriptionPart.Parent then
        self.descriptionPart.CFrame = self.mainPart.CFrame * CFrame.new(0, 0, 2)
    end
    
    self.needsResync = false
    self.lastKnownCFrame = rootPart.CFrame
end

function FollowController:smoothFollow()
    if not rootPart or not self.mainPart then return end
    if StateManager.systemLocked or self.isPaused then return end
    
    if self.dashCooldown > 0 then
        self.dashCooldown = math.max(0, self.dashCooldown - 0.1)
        return
    end
    
    if self:detectTeleport() or self.needsResync then
        self:forceResync()
        return
    end
    
    local distance = (self.mainPart.Position - rootPart.Position).Magnitude
    
    if distance > 25 then
        self:forceResync()
    elseif distance > 12 then
        local characterLook = rootPart.CFrame.LookVector
        local targetPos = rootPart.Position + (characterLook * 8) + Vector3.new(0, 2, 0)
        local lookAtPos = Vector3.new(rootPart.Position.X, self.mainPart.Position.Y, rootPart.Position.Z)
        self.mainPart.CFrame = self.mainPart.CFrame:Lerp(CFrame.new(targetPos, lookAtPos), 0.12)
    else
        local lookAtPos = Vector3.new(rootPart.Position.X, self.mainPart.Position.Y, rootPart.Position.Z)
        self.mainPart.CFrame = self.mainPart.CFrame:Lerp(CFrame.new(self.mainPart.Position, lookAtPos), 0.12)
    end
    
    if self.descriptionPart and self.descriptionPart.Parent then
        self.descriptionPart.CFrame = self.mainPart.CFrame * CFrame.new(0, 0, 2)
    end
end

function FollowController:startFollowing()
    if self.updateConnection then
        self.updateConnection:Disconnect()
    end
    
    self.updateConnection = RunService.Heartbeat:Connect(function()
        self:smoothFollow()
    end)
end

function FollowController:stopFollowing()
    if self.updateConnection then
        self.updateConnection:Disconnect()
        self.updateConnection = nil
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“Š ENHANCED STAT INFO WITH DETAILED DESCRIPTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local StatInfo = {
    strength = {
        name = "Strength",
        abbr = "STR",
        color = Color3.fromRGB(239, 68, 68),
        title = "ğŸŸ¥ STRENGTH (STR)",
        description = [[Physical Power & Combat Damage

EFFECTS:
â€¢ Increases melee damage output
â€¢ +2% damage per point
â€¢ Enhances Rampage mode damage
â€¢ Diminishing returns after 50 points

COMBAT BENEFITS:
â€¢ Higher kill potential
â€¢ Faster enemy elimination
â€¢ Increased threat level
â€¢ Enhanced Rampage performance

SCALING:
â€¢ Linear: 0-50 points (+2% each)
â€¢ Diminished: 50-100 points (+1.6% each)

RECOMMENDED FOR:
â€¢ Aggressive playstyle
â€¢ Boss encounters
â€¢ Rampage builds
â€¢ Pure damage dealers]],
        getEffect = function(val)
            local dmg = val * 2
            if val > 50 then
                dmg = 50 * 2 + ((val - 50) * 2 * 0.8)
            end
            return string.format("+%d%% DMG", math.floor(dmg))
        end
    },
    
    agility = {
        name = "Agility",
        abbr = "AGI",
        color = Color3.fromRGB(34, 197, 94),
        title = "ğŸŸ© AGILITY (AGI)",
        description = [[Speed & Movement Control

EFFECTS:
â€¢ Increases walk speed
â€¢ Improves dash speed (+4% per point)
â€¢ Reduces dash recovery time
â€¢ Enhances movement fluidity

MOVEMENT BENEFITS:
â€¢ Faster combat repositioning
â€¢ Better chase/escape capability
â€¢ Improved kiting potential
â€¢ Enhanced mobility in Rampage

SCALING:
â€¢ Walk Speed: +0.84 per point
â€¢ Dash Speed: +4% per point
â€¢ Maximum walk speed: 100

RECOMMENDED FOR:
â€¢ Mobile playstyle
â€¢ Hit-and-run tactics
â€¢ Evasion-focused builds
â€¢ Speed runners]],
        getEffect = function(val)
            return string.format("+%d SPD", math.floor(val * 0.84))
        end
    },
    
    perception = {
        name = "Perception",
        abbr = "PER",
        color = Color3.fromRGB(250, 204, 21),
        title = "ğŸŸ¨ PERCEPTION (PER)",
        description = [[Battle Control & Awareness

EFFECTS:
â€¢ Improves kill detection accuracy
â€¢ Increases assist-to-kill conversion
â€¢ +10 studs ability range per point
â€¢ +5% dash range per point
â€¢ -2% ability cooldown per point

COMBAT AWARENESS:
â€¢ Better kill credit recognition
â€¢ Enhanced damage tracking
â€¢ Improved assist detection
â€¢ Faster threat assessment

ABILITY BENEFITS:
â€¢ Longer Shadow Step range
â€¢ Extended Behind You range
â€¢ Increased Rampage duration
â€¢ Better cooldown efficiency

SCALING:
â€¢ Range: +10 studs per point
â€¢ Cooldown: -2% per point (max -60%)
â€¢ Kill Detection: +5% accuracy per point

RECOMMENDED FOR:
â€¢ Tactical players
â€¢ Support/Assist builds
â€¢ Ability-focused playstyle
â€¢ Team coordination]],
        getEffect = function(val)
            return string.format("+%d RNG", val * 10)
        end
    },
    
    vitality = {
        name = "Vitality",
        abbr = "VIT",
        color = Color3.fromRGB(168, 85, 247),
        title = "ğŸŸª VITALITY (VIT)",
        description = [[Body Toughness & Endurance

EFFECTS:
â€¢ Increases maximum health (+20 HP per point)
â€¢ Improves health regeneration (+0.5 HP/s)
â€¢ Unlocks Second Chance (10+ VIT)
â€¢ Enhanced survivability

DEFENSIVE BENEFITS:
â€¢ Higher health pool
â€¢ Passive health recovery
â€¢ Death prevention mechanic
â€¢ Extended combat duration

SECOND CHANCE SYSTEM:
â€¢ Requires: 10+ Vitality
â€¢ Effect: Revive at 50% HP on death
â€¢ Cooldown: 60 seconds
â€¢ Notification when ready

SCALING:
â€¢ Max HP: +20 per point
â€¢ Regen: +0.5 HP/second per point
â€¢ Second Chance: Active at 10+ VIT

RECOMMENDED FOR:
â€¢ Tank builds
â€¢ Survival-focused players
â€¢ Frontline fighters
â€¢ Solo content]],
        getEffect = function(val)
            return string.format("+%d HP", val * 20)
        end
    },
    
    intelligence = {
        name = "Intelligence",
        abbr = "INT",
        color = Color3.fromRGB(59, 130, 246),
        title = "ğŸŸ¦ INTELLIGENCE (INT)",
        description = [[Tactical Mind & System Efficiency

EFFECTS:
â€¢ Increases XP gain (+50 XP per point)
â€¢ Reduces ability cooldowns (-1% per point)
â€¢ Improves system responsiveness
â€¢ Enhances efficiency

PROGRESSION BENEFITS:
â€¢ Faster leveling
â€¢ More stat points over time
â€¢ Better skill point economy
â€¢ Accelerated growth

ABILITY BENEFITS:
â€¢ Shorter Shadow Step cooldown
â€¢ Faster Rampage recharge
â€¢ Reduced Behind You cooldown
â€¢ Better ability uptime

SCALING:
â€¢ XP Bonus: +50 per kill per point
â€¢ Cooldown: -1% per point
â€¢ Minimum cooldown: 50% reduction

RECOMMENDED FOR:
â€¢ Fast progression
â€¢ Ability-spam builds
â€¢ Efficiency-focused players
â€¢ Late-game scaling]],
        getEffect = function(val)
            return string.format("+%d XP", val * 50)
        end
    }
}
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“Š ABILITY CODEX (DETAILED SYSTEM-BASED DESCRIPTIONS)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local AbilityCodex = {
    ShadowStep = {
        name = "Shadow Step",
        category = "Movement",
        unlockLevel = 10,
        baseDescription = [[Teleport through shadows to target location.

DESCRIPTION:
Phase through the shadow realm to instantly
relocate. Pass through walls and obstacles.
Range and cooldown scale with stats.

MECHANICS:
â€¢ Instant teleportation
â€¢ Wall penetration
â€¢ Camera-directed targeting
â€¢ No line-of-sight required

LEVELING SYSTEM:
â€¢ Max Level: 50
â€¢ XP per use: 1
â€¢ Level 1-10: 5 uses per level
â€¢ Level 11-50: 8 uses per level

STAT SCALING:
â€¢ Perception: +10 range per point
â€¢ Perception: -2% cooldown per point (max -60%)
â€¢ Intelligence: -1% cooldown per point (min 50%)

VISUAL EFFECTS:
â€¢ Shadow portal at origin
â€¢ Purple trail during teleport
â€¢ Shadow portal at destination
â€¢ Lingering shadow particles

COMBAT USAGE:
â€¢ Engage distant targets
â€¢ Escape danger quickly
â€¢ Reposition mid-fight
â€¢ Flank enemies

INPUT:
â€¢ Keyboard: E
â€¢ Button: Shadow Step (left sidebar)]],
        
        getFullDescription = function(self, data)
            local range = Config.BASE_SHADOW_STEP_RANGE + (data.stats.perception * Config.STAT_CURVES.perception.rangePerPoint)
            local cdReduction = math.clamp(
                data.stats.perception * Config.STAT_CURVES.perception.cooldownReductionPerPoint,
                0,
                Config.STAT_CURVES.perception.maxCooldownReduction
            )
            local baseCooldown = Config.BASE_SHADOW_STEP_COOLDOWN * (1 - cdReduction)
            local finalCooldown = baseCooldown * math.max(
                1 - (data.stats.intelligence * Config.STAT_CURVES.intelligence.cooldownBonusPerPoint),
                0.5
            )
            
            local usesNeeded = data.shadowStep.level <= 10 and 5 or 8
            
            return string.format([[%s

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CURRENT STATISTICS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Range: %.1f studs
Cooldown: %.1f seconds
Level: %d / 50
Mastery Progress: %d / %d uses

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STAT CONTRIBUTIONS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Perception (%d):
  â€¢ Range Bonus: +%.1f studs
  â€¢ Cooldown Reduction: -%.1f%%

Intelligence (%d):
  â€¢ Cooldown Reduction: -%.1f%%

Total Cooldown Reduction: -%.1f%%

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PROGRESSION PATH:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Next Level: %d uses remaining
Total Uses: %d
Estimated Time to Max Level: ~%d uses

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]], 
                self.baseDescription, 
                range, 
                finalCooldown, 
                data.shadowStep.level,
                data.shadowStep.uses,
                usesNeeded,
                data.stats.perception,
                data.stats.perception * Config.STAT_CURVES.perception.rangePerPoint,
                cdReduction * 100,
                data.stats.intelligence,
                data.stats.intelligence * Config.STAT_CURVES.intelligence.cooldownBonusPerPoint * 100,
                (cdReduction + (data.stats.intelligence * Config.STAT_CURVES.intelligence.cooldownBonusPerPoint)) * 100,
                usesNeeded - data.shadowStep.uses,
                data.shadowStep.uses,
                (50 - data.shadowStep.level) * usesNeeded
            )
        end
    },
    
    Rampage = {
        name = "Rampage",
        category = "Ultimate",
        unlockLevel = 25,
        baseDescription = [[Enter awakened state with maxed stats.

DESCRIPTION:
Channel overwhelming power, temporarily
setting all stats to 100. Unlocks exclusive
"Behind You" ability during activation.

ACTIVATION SEQUENCE:
â€¢ Dramatic awakening cutscene (6.5s)
â€¢ Screen tremors and visual effects
â€¢ Ground cracks and energy release
â€¢ Full stat transformation

EFFECTS DURING RAMPAGE:
â€¢ All stats set to 100
â€¢ Maximum movement speed
â€¢ Enhanced damage output
â€¢ Behind You ability unlocked
â€¢ Instant Shadow Step cooldown reset
â€¢ Permanent red aura

RECHARGE SYSTEM:
â€¢ Base Cooldown: 300 seconds (5 minutes)
â€¢ Requires 5 kills after use
â€¢ Kill counter displays on button
â€¢ Visual notification when ready

STAT SCALING:
â€¢ Perception: +2.1 seconds duration per point
â€¢ Maximum duration: 300 seconds (5 minutes)
â€¢ Duration shown in status

STRATEGIC USAGE:
â€¢ Boss encounters
â€¢ Multiple enemy situations
â€¢ Emergency survival
â€¢ Maximum damage windows

VISUAL EFFECTS:
â€¢ Red energy cracks
â€¢ Intense screen shake
â€¢ Glowing red aura
â€¢ Stat transformation notifications

INPUT:
â€¢ Keyboard: R
â€¢ Button: RAGE (left sidebar)]],
        
        getFullDescription = function(self, data)
            local duration = math.min(
                90 + (data.stats.perception * Config.STAT_CURVES.perception.rampageDurationPerPoint),
                300
            )
            
            local cooldownStatus
            if data.rampage.cooldown > 0 then
                cooldownStatus = string.format("%.0f seconds (Kills: %d/5)", data.rampage.cooldown, data.rampage.currentKills)
            else
                cooldownStatus = "READY"
            end
            
            return string.format([[%s

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CURRENT STATISTICS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Duration: %.0f seconds
Cooldown: %s
Kills to Recharge: %d / 5
Status: %s

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STAT CONTRIBUTIONS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Perception (%d):
  â€¢ Duration Bonus: +%.0f seconds
  â€¢ Base Duration: 90 seconds
  â€¢ Total Duration: %.0f seconds

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ACTIVE EFFECTS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â€¢ Strength â†’ 100 (Damage Maximized)
â€¢ Agility â†’ 100 (Speed Maximized)
â€¢ Perception â†’ 100 (Range Maximized)
â€¢ Vitality â†’ 100 (Health Maximized)
â€¢ Intelligence â†’ 100 (XP/Cooldown Maximized)
â€¢ Behind You Ability Unlocked

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RECHARGE MECHANICS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
After Rampage ends:
1. 300 second base cooldown starts
2. Kill 5 enemies to reset cooldown
3. Notification appears when ready
4. Can be used again immediately

Current Progress:
â€¢ Cooldown Time: %s
â€¢ Kill Progress: %d / 5 enemies

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]], 
                self.baseDescription,
                duration,
                cooldownStatus,
                data.rampage.currentKills,
                data.rampage.cooldown > 0 and "RECHARGING" or "READY",
                data.stats.perception,
                data.stats.perception * Config.STAT_CURVES.perception.rampageDurationPerPoint,
                duration,
                data.rampage.cooldown > 0 and string.format("%.0fs remaining", data.rampage.cooldown) or "Ready",
                data.rampage.currentKills
            )
        end
    },
    
    BehindYou = {
        name = "Behind You",
        category = "Rampage-Only",
        unlockLevel = 25,
        baseDescription = [[Instantly teleport behind distant enemy.

DESCRIPTION:
Exclusive Rampage ability. Instantly appear
behind the nearest valid target within range.
Perfect for assassinations and repositioning.

REQUIREMENTS:
â€¢ Rampage must be active
â€¢ Enemy within 100-500 studs
â€¢ No line-of-sight required
â€¢ Not on cooldown

MECHANICS:
â€¢ Auto-targets nearest valid enemy
â€¢ Appears behind target's back
â€¢ Faces target after teleport
â€¢ Range: 100-500 studs minimum/maximum

TARGETING SYSTEM:
â€¢ Scans for players in range
â€¢ Selects nearest valid target
â€¢ Ignores allies (if applicable)
â€¢ Automatic threat prioritization

VISUAL EFFECTS:
â€¢ Shadow portal at origin
â€¢ Purple energy trail
â€¢ Shadow portal at destination
â€¢ Smoke particles on arrival
â€¢ Ground impact shockwave

STAT SCALING:
â€¢ Perception: -15% cooldown per point
â€¢ Minimum cooldown: 5 seconds
â€¢ Maximum reduction: 75%

COMBAT USAGE:
â€¢ Assassinate ranged enemies
â€¢ Close gaps instantly
â€¢ Surprise attacks
â€¢ Tactical repositioning

COOLDOWN MANAGEMENT:
â€¢ Scales with Perception
â€¢ Independent of Shadow Step
â€¢ Resets on Rampage end

INPUT:
â€¢ Keyboard: F
â€¢ Button: BEHIND YOU (appears during Rampage)]],
        
        getFullDescription = function(self, data)
            local cooldown = math.max(
                20 * (1 - math.clamp(data.stats.perception * Config.STAT_CURVES.perception.behindYouCDReductionPerPoint, 0, 0.75)),
                5
            )
            
            local cooldownReduction = math.clamp(data.stats.perception * Config.STAT_CURVES.perception.behindYouCDReductionPerPoint, 0, 0.75) * 100
            
            return string.format([[%s

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CURRENT STATISTICS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Cooldown: %.1f seconds
Minimum Range: %d studs
Maximum Range: %d studs
Status: %s

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STAT CONTRIBUTIONS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Perception (%d):
  â€¢ Cooldown Reduction: -%.1f%%
  â€¢ Base Cooldown: 20 seconds
  â€¢ Current Cooldown: %.1f seconds
  â€¢ Minimum Possible: 5 seconds

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TARGETING DETAILS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Range Requirements:
â€¢ Minimum: %d studs (too close = no target)
â€¢ Maximum: %d studs (too far = no target)
â€¢ Optimal: 150-400 studs

Target Selection:
â€¢ Scans all players in range
â€¢ Selects nearest valid enemy
â€¢ Ignores self
â€¢ Auto-prioritizes closest threat

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ACTIVATION REQUIREMENTS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âœ“ Rampage Mode Active
%s Cooldown Ready (%.1fs)
%s Valid Target in Range

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VISUAL SEQUENCE:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1. Shadow portal opens at your position
2. Character fades into purple energy
3. Trail follows teleport path
4. Shadow portal at destination
5. Smoke particles on arrival
6. Shockwave impact effect
7. Auto-face target's back

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]], 
                self.baseDescription,
                cooldown,
                Config.BEHIND_YOU_MIN_RANGE,
                Config.BEHIND_YOU_MAX_RANGE,
                data.rampage.isActive and "AVAILABLE" or "REQUIRES RAMPAGE",
                data.stats.perception,
                cooldownReduction,
                cooldown,
                Config.BEHIND_YOU_MIN_RANGE,
                Config.BEHIND_YOU_MAX_RANGE,
                data.behindYou.cooldown <= 0 and "âœ“" or "âœ—",
                data.behindYou.cooldown,
                data.rampage.isActive and "âœ“" or "âœ—"
            )
        end
    }
}

function AbilityCodex:getAbilityInfo(abilityName, playerData)
    local ability = self[abilityName]
    if not ability then return nil end
    
    return {
        name = ability.name,
        category = ability.category,
        unlockLevel = ability.unlockLevel,
        description = ability:getFullDescription(playerData)
    }
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“Š PLAYER DATA
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local savedData = DataModule.loadPlayerData()

local PlayerData = {
    stats = savedData and savedData.stats or {
        strength = 0,
        agility = 0,
        perception = 0,
        vitality = 0,
        intelligence = 0
    },
    level = savedData and savedData.level or 1,
    xp = savedData and savedData.xp or 0,
    maxHP = savedData and savedData.maxHP or 100,
    availablePoints = savedData and savedData.availablePoints or 5,
    shadowStep = {
        level = savedData and savedData.shadowStep and savedData.shadowStep.level or 1,
        uses = savedData and savedData.shadowStep and savedData.shadowStep.uses or 0,
        unlocked = savedData and savedData.shadowStep and savedData.shadowStep.unlocked or false,
        cooldown = 0,
        isActive = false
    },
    rampage = {
        unlocked = savedData and savedData.rampage and savedData.rampage.unlocked or false,
        isActive = false,
        duration = 90,
        cooldown = 0,
        maxCooldown = 300,
        killsRequired = 5,
        currentKills = savedData and savedData.rampage and savedData.rampage.currentKills or 0
    },
    behindYou = {
        cooldown = 0,
        maxCooldown = 20,
        minCooldown = 5
    },
    combatEngagement = {},
    assistEngagement = {},
    damageDealt = {},
    hasSecondChance = true
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“ˆ RANK DATA
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local RankData = {
    {name = "E-RANK", level = 1, color = Color3.fromRGB(176, 176, 176), title = "The Weakest Hunter", status = "NORMAL"},
    {name = "D-RANK", level = 10, color = Color3.fromRGB(79, 195, 247), title = "Awakened", status = "NORMAL"},
    {name = "C-RANK", level = 20, color = Color3.fromRGB(76, 175, 80), title = "Elite Hunter", status = "NORMAL"},
    {name = "B-RANK", level = 35, color = Color3.fromRGB(255, 193, 7), title = "Elite Hunter", status = "HIGH"},
    {name = "A-RANK", level = 50, color = Color3.fromRGB(255, 112, 67), title = "Apex Hunter", status = "RARE"},
    {name = "S-RANK", level = 70, color = Color3.fromRGB(211, 47, 47), title = "National Threat", status = "EXTREMELY RARE"},
    {name = "NATIONAL", level = 90, color = Color3.fromRGB(138, 43, 226), title = "National Power", status = "CLASSIFIED"},
    {name = "MONARCH", level = 100, color = Color3.fromRGB(0, 0, 0), title = "Shadow Monarch", status = "UNKNOWN"}
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ§® STAT CALCULATOR
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local StatCalculator = {}

function StatCalculator.applyStatEffects()
    if not humanoid then return end
    
    local stats = PlayerData.stats
    local curves = Config.STAT_CURVES
    local healthPercent = humanoid.Health / humanoid.MaxHealth
    
    humanoid.WalkSpeed = math.min(
        Config.BASE_WALK_SPEED + (stats.agility * curves.agility.walkSpeedPerPoint),
        Config.MAX_WALK_SPEED
    )
    
    _G.dashSpeed = Config.BASE_DASH_SPEED * (1 + stats.agility * curves.agility.dashSpeedPerPoint)
    _G.dashRange = Config.BASE_DASH_RANGE * (1 + stats.perception * curves.perception.dashRangePerPoint)
    _G.shadowStepRange = Config.BASE_SHADOW_STEP_RANGE + (stats.perception * curves.perception.rangePerPoint)
    
    local cdReduction = math.clamp(
        stats.perception * curves.perception.cooldownReductionPerPoint,
        0,
        curves.perception.maxCooldownReduction
    )
    _G.shadowStepMaxCooldown = Config.BASE_SHADOW_STEP_COOLDOWN * (1 - cdReduction)
    _G.shadowStepMaxCooldown = _G.shadowStepMaxCooldown * math.max(
        1 - (stats.intelligence * curves.intelligence.cooldownBonusPerPoint),
        0.5
    )
    
    PlayerData.rampage.duration = math.min(
        90 + (stats.perception * curves.perception.rampageDurationPerPoint),
        300
    )
    
    PlayerData.behindYou.maxCooldown = math.max(
        20 * (1 - math.clamp(stats.perception * curves.perception.behindYouCDReductionPerPoint, 0, 0.75)),
        PlayerData.behindYou.minCooldown
    )
    
    PlayerData.maxHP = 100 + (stats.vitality * curves.vitality.hpPerPoint)
    humanoid.MaxHealth = PlayerData.maxHP
    humanoid.Health = PlayerData.maxHP * healthPercent
    
    PlayerData.hasSecondChance = stats.vitality >= curves.vitality.secondChanceThreshold
    
    DataModule.savePlayerData(PlayerData)
end

function StatCalculator.getDamageMultiplier()
    local str = PlayerData.stats.strength
    local damage = str * 2
    if str > 50 then
        damage = 50 * 2 + ((str - 50) * 2 * 0.8)
    end
    return 1 + (damage / 100)
end

function StatCalculator.getXPBonus()
    return PlayerData.stats.intelligence * 50
end

function StatCalculator.getKillDetectionBonus()
    return 1 + (PlayerData.stats.perception * Config.STAT_CURVES.perception.killDetectionBonus)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“Š LEVEL SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local LevelSystem = {}

function LevelSystem.calculateRequiredXP(level)
    return math.floor(100 * (level ^ 1.15))
end

function LevelSystem.getCurrentRank()
    for i = #RankData, 1, -1 do
        if PlayerData.level >= RankData[i].level then
            return RankData[i]
        end
    end
    return RankData[1]
end

function LevelSystem.getCurrentClass()
    if PlayerData.level >= 100 then return "Shadow Monarch"
    elseif PlayerData.level >= 71 then return "Shadow Commander"
    elseif PlayerData.level >= 41 then return "Shadow Warrior"
    elseif PlayerData.level >= 21 then return "Shadow Adept"
    else return "Unclassified" end
end

function LevelSystem.grantXP(amount)
    if PlayerData.rampage.isActive then return end
    PlayerData.xp = PlayerData.xp + amount
    local maxXP = LevelSystem.calculateRequiredXP(PlayerData.level)

    while PlayerData.xp >= maxXP and PlayerData.level < Config.LEVEL_CAP do
        PlayerData.xp = PlayerData.xp - maxXP
        PlayerData.level = PlayerData.level + 1
        PlayerData.availablePoints = PlayerData.availablePoints + Config.POINTS_PER_LEVEL
        
        task.spawn(function()
            EffectsModule.createLevelUpEffect()
        end)
        
        PlayerData.maxHP = 100 + (PlayerData.stats.vitality * 20)
        humanoid.MaxHealth = PlayerData.maxHP
        humanoid.Health = PlayerData.maxHP
        
        if PlayerData.level >= Config.SHADOW_STEP_UNLOCK_LEVEL and not PlayerData.shadowStep.unlocked then
            PlayerData.shadowStep.unlocked = true
            UIModule.updateAbilityButtons()
        end
        
        if PlayerData.level >= Config.RAMPAGE_UNLOCK_LEVEL and not PlayerData.rampage.unlocked then
            PlayerData.rampage.unlocked = true
            UIModule.updateAbilityButtons()
            task.spawn(function()
                EffectsModule.createRampageUnlockEffect()
            end)
        end
        
        maxXP = LevelSystem.calculateRequiredXP(PlayerData.level)
    end

    UIModule.updateUI()
    DataModule.savePlayerData(PlayerData)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âš”ï¸ ENHANCED COMBAT SYSTEM (PERFECT KILL/ASSIST TRACKING)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local CombatModule = {}

function CombatModule.recordDamage(victimUserId, damage, victimHumanoid)
    local currentTime = tick()
    
    if not PlayerData.combatEngagement[victimUserId] then
        PlayerData.combatEngagement[victimUserId] = {
            totalDamage = 0,
            lastHit = currentTime,
            firstHit = currentTime,
            maxHealth = victimHumanoid and victimHumanoid.MaxHealth or 100,
            damagePercent = 0
        }
    end

    PlayerData.combatEngagement[victimUserId].totalDamage = PlayerData.combatEngagement[victimUserId].totalDamage + damage
    PlayerData.combatEngagement[victimUserId].lastHit = currentTime
    
    -- Calculate damage percentage with perception bonus
    if victimHumanoid then
        local damagePercent = (PlayerData.combatEngagement[victimUserId].totalDamage / victimHumanoid.MaxHealth) * 100
        PlayerData.combatEngagement[victimUserId].damagePercent = damagePercent * StatCalculator.getKillDetectionBonus()
    end
end

function CombatModule.recordAssist(victimUserId, attackerPlayer, victimHumanoid)
    local currentTime = tick()
    
    if not PlayerData.assistEngagement[victimUserId] then
        PlayerData.assistEngagement[victimUserId] = {
            primaryAttacker = attackerPlayer,
            lastSeen = currentTime,
            playerDamaged = false,
            proximity = true,
            maxHealth = victimHumanoid and victimHumanoid.MaxHealth or 100
        }
    end

    PlayerData.assistEngagement[victimUserId].lastSeen = currentTime
end

function CombatModule.validateKill(victimUserId)
    local engagement = PlayerData.combatEngagement[victimUserId]
    if not engagement then return false end
    
    local currentTime = tick()
    local timeSinceLastHit = currentTime - engagement.lastHit
    
    -- Enhanced validation with perception scaling
    local damageThreshold = Config.MIN_DAMAGE_FOR_CREDIT / StatCalculator.getKillDetectionBonus()
    local sufficientDamage = engagement.totalDamage >= damageThreshold
    local recentHit = timeSinceLastHit <= Config.COMBAT_TIMEOUT
    
    -- Additional validation: check if player dealt significant portion of damage
    local significantContribution = engagement.damagePercent >= 30 -- 30% of max health
    
    return recentHit and (sufficientDamage or significantContribution)
end

function CombatModule.validateAssist(victimUserId)
    local assist = PlayerData.assistEngagement[victimUserId]
    if not assist then return false end
    
    local currentTime = tick()
    local timeSinceLastSeen = currentTime - assist.lastSeen
    
    -- Check if player was involved but didn't get kill credit
    local wasInvolved = timeSinceLastSeen <= Config.ASSIST_TIME_WINDOW
    local hadProximity = assist.proximity
    local hadDamage = assist.playerDamaged
    
    return wasInvolved and (hadProximity or hadDamage)
end

function CombatModule.onPlayerKilled(victim, killer)
    if not victim or not victim.UserId then return end
    
    local userId = victim.UserId
    local totalXP = 0
    
    -- Check if player gets kill credit
    if killer == player and CombatModule.validateKill(userId) then
        totalXP = Config.BASE_KILL_XP + StatCalculator.getXPBonus()
        LevelSystem.grantXP(totalXP)
        
        -- Rampage kill counter
        if PlayerData.rampage.cooldown > 0 then
            PlayerData.rampage.currentKills = PlayerData.rampage.currentKills + 1
            
            if PlayerData.rampage.currentKills >= PlayerData.rampage.killsRequired then
                PlayerData.rampage.cooldown = 0
                PlayerData.rampage.currentKills = 0
                
                NotificationQueue:add({
                    text = "RAMPAGE READY",
                    offset = Vector3.new(0, 3, 0),
                    duration = 1.5,
                    color = Color3.fromRGB(255, 60, 60)
                })
            end
            
            UIModule.updateAbilityButtons()
        end
        
        if rootPart then
            task.spawn(function()
                EffectsModule.createXPPopup(totalXP, rootPart.Position, "KILL")
            end)
        end
        
        -- Log kill for data tracking
        print(string.format("âœ… KILL CREDIT: %s | Damage: %.0f (%.1f%%) | XP: +%d", 
            victim.Name,
            PlayerData.combatEngagement[userId].totalDamage,
            PlayerData.combatEngagement[userId].damagePercent,
            totalXP
        ))
        
        PlayerData.combatEngagement[userId] = nil
        
    -- Check if player gets assist credit
    elseif killer ~= player and CombatModule.validateAssist(userId) then
        -- Bonus assist credit if player dealt some damage
        local damageBonus = 1.0
        if PlayerData.combatEngagement[userId] then
            damageBonus = 1 + (PlayerData.combatEngagement[userId].damagePercent / 100)
        end
        
        totalXP = math.floor((Config.BASE_KILL_XP + StatCalculator.getXPBonus()) * Config.ASSIST_XP_MULTIPLIER * damageBonus)
        LevelSystem.grantXP(totalXP)
        
        if rootPart then
            task.spawn(function()
                EffectsModule.createXPPopup(totalXP, rootPart.Position, "ASSIST")
            end)
        end
        
        -- Log assist for data tracking
        print(string.format("ğŸ¤ ASSIST CREDIT: %s | Bonus: %.0f%% | XP: +%d", 
            victim.Name,
            (damageBonus - 1) * 100,
            totalXP
        ))
        
        PlayerData.assistEngagement[userId] = nil
        if PlayerData.combatEngagement[userId] then
            PlayerData.combatEngagement[userId] = nil
        end
    else
        -- No credit - log why
        if PlayerData.combatEngagement[userId] then
            print(string.format("âŒ NO CREDIT: %s | Timeout: %.1fs | Damage: %.0f", 
                victim.Name,
                tick() - PlayerData.combatEngagement[userId].lastHit,
                PlayerData.combatEngagement[userId].totalDamage
            ))
        end
    end
    
    -- Auto-save on kill/assist
    DataModule.savePlayerData(PlayerData)
end

-- Enhanced health monitoring with better damage tracking
function CombatModule.setupHealthMonitoring(otherPlayer)
    if not otherPlayer or not otherPlayer.Character then return end
    
    local otherHumanoid = otherPlayer.Character:FindFirstChild("Humanoid")
    if not otherHumanoid or otherHumanoid:GetAttribute("Monitored") then return end

    otherHumanoid:SetAttribute("Monitored", true)

    local lastHealth = otherHumanoid.Health
    local lastDamageTime = tick()

    otherHumanoid.HealthChanged:Connect(function(health)
        if health < lastHealth and rootPart and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            
            if otherRoot then
                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                local damage = lastHealth - health
                local currentTime = tick()
                
                -- Direct combat range (player dealt damage)
                if distance <= 35 and currentTime - lastDamageTime <= 0.5 then
                    CombatModule.recordDamage(otherPlayer.UserId, damage, otherHumanoid)
                    lastDamageTime = currentTime
                    
                -- Assist range (player nearby but didn't deal damage)
                elseif distance <= Config.ASSIST_RANGE then
                    -- Find who actually dealt the damage
                    for _, p in pairs(Players:GetPlayers()) do
                        if p ~= player and p ~= otherPlayer and p.Character then
                            local pRoot = p.Character:FindFirstChild("HumanoidRootPart")
                            if pRoot and (pRoot.Position - otherRoot.Position).Magnitude <= 35 then
                                CombatModule.recordAssist(otherPlayer.UserId, p, otherHumanoid)
                                if PlayerData.assistEngagement[otherPlayer.UserId] then
                                    PlayerData.assistEngagement[otherPlayer.UserId].playerDamaged = true
                                end
                                break
                            end
                        end
                    end
                end
            end
        end
        
        lastHealth = health
    end)

    otherHumanoid.Died:Connect(function()
        -- Find who killed them
        local killer = player -- Assume player killed if we have combat engagement
        
        if not CombatModule.validateKill(otherPlayer.UserId) then
            -- Check for other nearby players who might have killed them
            for _, p in pairs(Players:GetPlayers()) do
                if p ~= player and p.Character then
                    local pRoot = p.Character:FindFirstChild("HumanoidRootPart")
                    local otherRoot = otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if pRoot and otherRoot and (pRoot.Position - otherRoot.Position).Magnitude <= 35 then
                        killer = p
                        break
                    end
                end
            end
        end
        
        CombatModule.onPlayerKilled(otherPlayer, killer)
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ¨ EFFECTS MODULE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EffectsModule = {}

function EffectsModule.createXPPopup(amount, position, type)
    if PlayerData.rampage.isActive then return end
    
    local part = Instance.new("Part")
    part.Size = Vector3.new(5, 3, 0.1)
    part.Position = position + Vector3.new(0, 4, 0)
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Parent = workspace
    
    local gui = Instance.new("BillboardGui")
    gui.Size = UDim2.new(0, 300, 0, 150)
    gui.StudsOffset = Vector3.new(0, 2, 0)
    gui.AlwaysOnTop = true
    gui.Parent = part

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.GothamBold
    label.TextSize = type == "KILL" and 36 or 28
    label.Text = type == "KILL" and ("+" .. amount .. " XP") or ("+" .. amount .. " XP [ASSIST]")
    label.TextColor3 = type == "KILL" and Color3.fromRGB(34, 211, 238) or Color3.fromRGB(250, 204, 21)
    label.Parent = gui

    TweenService:Create(gui, TweenInfo.new(1.5), {StudsOffset = Vector3.new(0, 5, 0)}):Play()
    TweenService:Create(label, TweenInfo.new(1.5), {TextTransparency = 1}):Play()
    Debris:AddItem(part, 1.5)
end

function EffectsModule.createLevelUpEffect()
    if not rootPart then return end
    
    -- Triple pillar effect
    for i = 1, 3 do
        task.spawn(function()
            local pillar = Instance.new("Part")
            pillar.Size = Vector3.new(10, 60, 10)
            pillar.Position = rootPart.Position
            pillar.Anchored = true
            pillar.CanCollide = false
            pillar.Material = Enum.Material.Neon
            pillar.Color = i == 1 and Color3.fromRGB(255, 215, 0) or i == 2 and Color3.fromRGB(255, 165, 0) or Color3.fromRGB(255, 255, 255)
            pillar.Transparency = 0.3 + (i * 0.1)
            pillar.Parent = workspace
            
            local mesh = Instance.new("CylinderMesh")
            mesh.Parent = pillar
            
            task.wait(i * 0.1)
            
            TweenService:Create(pillar, TweenInfo.new(1.2), {
                Transparency = 1,
                Size = Vector3.new(15 + (i * 2), 60, 15 + (i * 2))
            }):Play()
            
            Debris:AddItem(pillar, 1.2)
        end)
    end

    -- Explosion wave
    local wave = Instance.new("Part")
    wave.Size = Vector3.new(2, 0.5, 2)
    wave.Position = rootPart.Position
    wave.Anchored = true
    wave.CanCollide = false
    wave.Material = Enum.Material.Neon
    wave.Color = Color3.fromRGB(255, 215, 0)
    wave.Transparency = 0.3
    wave.Parent = workspace

    local mesh = Instance.new("CylinderMesh")
    mesh.Parent = wave

    TweenService:Create(wave, TweenInfo.new(0.8), {
        Size = Vector3.new(40, 0.5, 40),
        Transparency = 1
    }):Play()

    Debris:AddItem(wave, 0.8)

    -- Enhanced particles
    for i = 1, Config.VFX.LEVEL_UP_PARTICLES do
        task.spawn(function()
            local part = Instance.new("Part")
            part.Size = Vector3.new(0.8, 0.8, 0.8)
            part.Position = rootPart.Position + Vector3.new(
                math.random(-4, 4),
                math.random(-2, 4),
                math.random(-4, 4)
            )
            part.Anchored = true
            part.CanCollide = false
            part.Material = Enum.Material.Neon
            part.Color = i % 2 == 0 and Color3.fromRGB(255, 215, 0) or Color3.fromRGB(255, 255, 255)
            part.Shape = Enum.PartType.Ball
            part.Parent = workspace
            
            TweenService:Create(part, TweenInfo.new(1.5), {
                Position = part.Position + Vector3.new(
                    math.random(-6, 6),
                    math.random(8, 15),
                    math.random(-6, 6)
                ),
                Transparency = 1,
                Size = Vector3.new(0.1, 0.1, 0.1)
            }):Play()
            
            Debris:AddItem(part, 1.5)
        end)
    end
end

function EffectsModule.createStatUpgradeEffect(statName)
    if not rootPart then return end
    
    local statColor = StatInfo[statName].color
    
    for i = 1, Config.VFX.STAT_UPGRADE_ORBS do
        local angle = (i / Config.VFX.STAT_UPGRADE_ORBS) * math.pi * 2
        local part = Instance.new("Part")
        part.Size = Vector3.new(0.8, 0.8, 0.8)
        part.Shape = Enum.PartType.Ball
        part.Position = rootPart.Position + Vector3.new(
            math.cos(angle) * 3,
            2,
            math.sin(angle) * 3
        )
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.Color = statColor
        part.Parent = workspace
        
        TweenService:Create(part, TweenInfo.new(0.8), {
            Position = rootPart.Position + Vector3.new(0, 2, 0),
            Transparency = 1,
            Size = Vector3.new(0.2, 0.2, 0.2)
        }):Play()
        
        Debris:AddItem(part, 0.8)
    end
end

function EffectsModule.createShadowPortal(position)
    local portal = Instance.new("Part")
    portal.Size = Vector3.new(6, 0.4, 6)
    portal.Position = position
    portal.Anchored = true
    portal.CanCollide = false
    portal.Material = Enum.Material.Neon
    portal.Color = Color3.fromRGB(10, 10, 10)
    portal.Transparency = 0.2
    portal.Parent = workspace
    
    local rim = Instance.new("Part")
    rim.Size = Vector3.new(7, 0.5, 7)
    rim.Position = position
    rim.Anchored = true
    rim.CanCollide = false
    rim.Material = Enum.Material.Neon
    rim.Color = Color3.fromRGB(138, 43, 226)
    rim.Transparency = 0.4
    rim.Parent = workspace

    Instance.new("CylinderMesh").Parent = rim
    Instance.new("CylinderMesh").Parent = portal

    for i = 1, Config.VFX.SHADOW_PORTAL_PARTICLES do
        local particle = Instance.new("Part")
        particle.Size = Vector3.new(0.3, 0.3, 0.3)
        particle.Position = position + Vector3.new(
            math.random(-3, 3),
            0.5,
            math.random(-3, 3)
        )
        particle.Anchored = true
        particle.CanCollide = false
        particle.Material = Enum.Material.Neon
        particle.Color = Color3.fromRGB(138, 43, 226)
        particle.Transparency = 0.5
        particle.Parent = workspace
        
        TweenService:Create(particle, TweenInfo.new(0.5), {
            Position = position + Vector3.new(0, 3, 0),
            Transparency = 1
        }):Play()
        
        Debris:AddItem(particle, 0.5)
    end

    TweenService:Create(portal, TweenInfo.new(0.5), {
        Transparency = 1,
        Size = Vector3.new(10, 0.4, 10)
    }):Play()

    TweenService:Create(rim, TweenInfo.new(0.5), {
        Transparency = 1,
        Size = Vector3.new(12, 0.5, 12)
    }):Play()

    Debris:AddItem(portal, 0.5)
    Debris:AddItem(rim, 0.5)
end

function EffectsModule.createShadowStepTrail(startPos, endPos)
    for i = 1, 10 do
        local progress = i / 10
        local pos = startPos:Lerp(endPos, progress)
        
        local trail = Instance.new("Part")
        trail.Size = Vector3.new(1.5, 3, 1.5)
        trail.Position = pos
        trail.Anchored = true
        trail.CanCollide = false
        trail.Material = Enum.Material.Neon
        trail.Color = Color3.fromRGB(138, 43, 226)
        trail.Transparency = 0.3
        trail.Parent = workspace
        
        TweenService:Create(trail, TweenInfo.new(0.4), {
            Transparency = 1,
            Size = Vector3.new(0.5, 1, 0.5)
        }):Play()
        
        Debris:AddItem(trail, 0.4)
    end
end

function EffectsModule.createSecondChanceEffect()
    if not rootPart then return end
    
    for i = 1, 20 do
        local part = Instance.new("Part")
        part.Size = Vector3.new(0.8, 0.8, 0.8)
        part.Position = rootPart.Position + Vector3.new(
            math.random(-2, 2),
            math.random(0, 3),
            math.random(-2, 2)
        )
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(168, 85, 247)
        part.Transparency = 0.3
        part.Parent = workspace
        
        TweenService:Create(part, TweenInfo.new(1.2), {
            Position = rootPart.Position,
            Transparency = 1,
            Size = Vector3.new(0.2, 0.2, 0.2)
        }):Play()
        
        Debris:AddItem(part, 1.2)
    end
end

function EffectsModule.createRampageUnlockEffect()
    if not rootPart then return end
    
    local playerGui = player:WaitForChild("PlayerGui")
    local flash = Instance.new("Frame")
    flash.Size = UDim2.new(1, 0, 1, 0)
    flash.BackgroundColor3 = Color3.fromRGB(211, 47, 47)
    flash.BackgroundTransparency = 0
    flash.BorderSizePixel = 0
    flash.ZIndex = 100
    flash.Parent = playerGui
    
    TweenService:Create(flash, TweenInfo.new(1.5), {
        BackgroundTransparency = 1
    }):Play()

    Debris:AddItem(flash, 1.5)

    NotificationQueue:add({
        text = "RAMPAGE UNLOCKED",
        offset = Vector3.new(0, 3, 0),
        duration = 2,
        color = Color3.fromRGB(255, 60, 60)
    })
end

function EffectsModule.createRampageCutscene()
    local camera = workspace.CurrentCamera
    local originalCFrame = camera.CFrame
    local originalFOV = camera.FieldOfView
    
    StateManager:lock(6.5)
    NotificationQueue:pause()
    NotificationQueue:clear()
    
    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0
    
    -- Screen flash
    local playerGui = player:WaitForChild("PlayerGui")
    local redFlash = Instance.new("Frame")
    redFlash.Size = UDim2.new(1, 0, 1, 0)
    redFlash.BackgroundColor3 = Color3.fromRGB(139, 0, 0)
    redFlash.BackgroundTransparency = 1
    redFlash.BorderSizePixel = 0
    redFlash.ZIndex = 99
    redFlash.Parent = playerGui

    -- Phase 1: Ground cracks with intensity
    for i = 1, 16 do
        task.spawn(function()
            local angle = (i / 16) * math.pi * 2
            local crack = Instance.new("Part")
            crack.Size = Vector3.new(1.5, 0.8, 12)
            crack.Position = rootPart.Position + Vector3.new(
                math.cos(angle) * 5,
                -2.5,
                math.sin(angle) * 5
            )
            crack.Anchored = true
            crack.CanCollide = false
            crack.Material= Enum.Material.Neon
            crack.Color = Color3.fromRGB(139, 0, 0)
            crack.Transparency = 0.2
            crack.Parent = workspace
            
            TweenService:Create(crack, TweenInfo.new(0.6), {
                Size = Vector3.new(2, 0.8, 20),
                Transparency = 1
            }):Play()
            
            Debris:AddItem(crack, 0.6)
        end)
    end

    -- Phase 2: Intense camera shake + FOV
    task.spawn(function()
        for i = 1, 80 do
            local intensity = (i <= 40 and (i / 40) or (80 - i) / 40) * 1.5
            camera.CFrame = originalCFrame * CFrame.Angles(
                math.rad(math.random(-8, 8) * intensity),
                math.rad(math.random(-8, 8) * intensity),
                math.rad(math.random(-5, 5) * intensity)
            )
            camera.FieldOfView = originalFOV + (math.sin(i / 5) * 10 * intensity)
            task.wait(0.025)
        end
        camera.CFrame = originalCFrame
        camera.FieldOfView = originalFOV
    end)

    -- Flash pulse
    task.spawn(function()
        for i = 1, 4 do
            TweenService:Create(redFlash, TweenInfo.new(0.15), {BackgroundTransparency = 0.3}):Play()
            task.wait(0.15)
            TweenService:Create(redFlash, TweenInfo.new(0.15), {BackgroundTransparency = 0.9}):Play()
            task.wait(0.4)
        end
    end)

    -- Phase 3: Notifications
    task.wait(2)
    NotificationQueue:add({
        text = "AWAKENING",
        offset = Vector3.new(0, 5, 0),
        duration = 1.2,
        color = Color3.fromRGB(255, 60, 60)
    })
    task.wait(1.2)

    local statOrder = {"strength", "perception", "agility", "vitality", "intelligence"}
    for i, statName in ipairs(statOrder) do
        local angle = ((i - 1) / #statOrder) * math.pi * 2
        local offset = Vector3.new(
            math.cos(angle) * 4,
            4,
            math.sin(angle) * 4
        )
        NotificationQueue:add({
            text = StatInfo[statName].abbr .. ": 100",
            offset = offset,
            duration = 0.5,
            color = StatInfo[statName].color
        })
    end

    task.wait(0.7)
    NotificationQueue:add({
        text = "RAMPAGE MODE",
        offset = Vector3.new(0, 6, 0),
        duration = 2,
        color = Color3.fromRGB(139, 0, 0)
    })

    -- Phase 4: Massive explosion
    task.wait(1.8)

    TweenService:Create(redFlash, TweenInfo.new(0.1), {BackgroundTransparency = 0}):Play()
    task.wait(0.1)
    TweenService:Create(redFlash, TweenInfo.new(0.8), {BackgroundTransparency = 1}):Play()

    local explosion = Instance.new("Part")
    explosion.Size = Vector3.new(8, 8, 8)
    explosion.Position = rootPart.Position
    explosion.Anchored = true
    explosion.CanCollide = false
    explosion.Material = Enum.Material.Neon
    explosion.Color = Color3.fromRGB(139, 0, 0)
    explosion.Transparency = 0.2
    explosion.Shape = Enum.PartType.Ball
    explosion.Parent = workspace

    TweenService:Create(explosion, TweenInfo.new(0.6), {
        Size = Vector3.new(80, 80, 80),
        Transparency = 1
    }):Play()

    Debris:AddItem(explosion, 0.6)
    Debris:AddItem(redFlash, 1)

    task.wait(0.7)
    NotificationQueue:resume()
end

function EffectsModule.createRampageAura()
    if not rootPart then return end
    
    local auraConnection
    auraConnection = RunService.Heartbeat:Connect(function()
        if not PlayerData.rampage.isActive or not rootPart then
            auraConnection:Disconnect()
            return
        end
        
        if math.random() > 0.6 then
            local aura = Instance.new("Part")
            aura.Size = Vector3.new(1.2, 1.2, 1.2)
            aura.Position = rootPart.Position + Vector3.new(
                math.random(-3, 3),
                math.random(-1, 3),
                math.random(-3, 3)
            )
            aura.Anchored = true
            aura.CanCollide = false
            aura.Material = Enum.Material.Neon
            aura.Color = Color3.fromRGB(139, 0, 0)
            aura.Transparency = 0.3
            aura.Parent = workspace
            
            TweenService:Create(aura, TweenInfo.new(0.7), {
                Position = aura.Position + Vector3.new(0, 3, 0),
                Transparency = 1,
                Size = Vector3.new(0.2, 0.2, 0.2)
            }):Play()
            
            Debris:AddItem(aura, 0.7)
        end
    end)
end

function EffectsModule.createBehindYouEffect(startPos, targetPos)
    EffectsModule.createShadowPortal(startPos)
    
    local fadeClone = character:Clone()
    for _, part in pairs(fadeClone:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Anchored = true
            part.CanCollide = false
            part.Material = Enum.Material.Neon
            part.Color = Color3.fromRGB(138, 43, 226)
            TweenService:Create(part, TweenInfo.new(0.3), {
                Transparency = 1
            }):Play()
        end
    end
    fadeClone.Parent = workspace
    Debris:AddItem(fadeClone, 0.3)
    
    for i = 1, 15 do
        task.spawn(function()
            local progress = i / 15
            local pos = startPos:Lerp(targetPos, progress)
            
            local shadow = Instance.new("Part")
            shadow.Size = Vector3.new(2, 4, 2)
shadow.Position = pos
     shadow.Anchored = true
     shadow.CanCollide = false
     shadow.Material = Enum.Material.Neon
     shadow.Color = Color3.fromRGB(75, 0, 130)
     shadow.Transparency = 0.5
     shadow.Parent = workspace

     TweenService:Create(shadow, TweenInfo.new(0.5), {
         Transparency = 1,
         Size = Vector3.new(0.5, 1, 0.5)
     }):Play()

     Debris:AddItem(shadow, 0.5)
 end)
end
task.wait(0.15)
EffectsModule.createShadowPortal(targetPos)
for i = 1, Config.VFX.BEHIND_YOU_SMOKE do
task.spawn(function()
local smoke = Instance.new("Part")
smoke.Size = Vector3.new(1, 1, 1)
smoke.Position = targetPos + Vector3.new(
math.random(-2, 2),
math.random(0, 3),
math.random(-2, 2)
)
smoke.Anchored = true
smoke.CanCollide = false
smoke.Material = Enum.Material.Neon
smoke.Color = Color3.fromRGB(75, 0, 130)
smoke.Transparency = 0.3
smoke.Parent = workspace
local mesh = Instance.new("SpecialMesh")
     mesh.MeshType = Enum.MeshType.Sphere
     mesh.Parent = smoke

     TweenService:Create(smoke, TweenInfo.new(0.6), {
         Position = smoke.Position + Vector3.new(
             math.random(-4, 4),
             math.random(2, 5),
             math.random(-4, 4)
         ),
         Size = Vector3.new(2, 2, 2),
         Transparency = 1
     }):Play()

     Debris:AddItem(smoke, 0.6)
 end)
end
local arrivalShock = Instance.new("Part")
arrivalShock.Size = Vector3.new(2, 0.5, 2)
arrivalShock.Position = targetPos
arrivalShock.Anchored = true
arrivalShock.CanCollide = false
arrivalShock.Material = Enum.Material.Neon
arrivalShock.Color = Color3.fromRGB(138, 43, 226)
arrivalShock.Transparency = 0.3
arrivalShock.Parent = workspace
Instance.new("CylinderMesh").Parent = arrivalShock
TweenService:Create(arrivalShock, TweenInfo.new(0.5), {
Size = Vector3.new(15, 0.5, 15),
Transparency = 1
}):Play()
Debris:AddItem(arrivalShock, 0.5)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âš¡ ABILITY SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local AbilityModule = {}

function AbilityModule.performShadowStep()
    if PlayerData.shadowStep.isActive
        or PlayerData.shadowStep.cooldown > 0
        or not PlayerData.shadowStep.unlocked
        or not rootPart
        or PlayerData.rampage.isActive
        or not AnimationLock:acquire("shadow_step", 0.5)
        or not InputAuthority:canUseAbility()
    then
        return
    end
    
    InputAuthority:lockAbilities(0.5)
    PlayerData.shadowStep.isActive = true

    local camera = workspace.CurrentCamera
    local lookVector = camera.CFrame.LookVector
    local targetPos = rootPart.Position + (lookVector * (_G.shadowStepRange or 50))

    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {character}
    rayParams.FilterType = Enum.RaycastFilterType.Exclude

    local ray = workspace:Raycast(rootPart.Position, lookVector * (_G.shadowStepRange or 50), rayParams)
    if ray then
        targetPos = ray.Position + (ray.Normal * 3)
    end

    task.spawn(function()
        EffectsModule.createShadowPortal(rootPart.Position)
        EffectsModule.createShadowStepTrail(rootPart.Position, targetPos)
    end)

    rootPart.CFrame = CFrame.new(targetPos, targetPos + lookVector)
    FollowController:signalMovementOverride()

    task.spawn(function()
        EffectsModule.createShadowPortal(targetPos)
    end)

    PlayerData.shadowStep.uses = PlayerData.shadowStep.uses + 1
    local usesNeeded = PlayerData.shadowStep.level <= 10 and 5 or 8

    if PlayerData.shadowStep.uses >= usesNeeded and PlayerData.shadowStep.level < 50 then
        PlayerData.shadowStep.level = PlayerData.shadowStep.level + 1
        PlayerData.shadowStep.uses = 0
        NotificationQueue:add({
            text = "SHADOW STEP LV UP",
            offset = Vector3.new(0, 3, 0),
            duration = 1.5,
            color = Color3.fromRGB(138, 43, 226)
        })
    end

    PlayerData.shadowStep.cooldown = _G.shadowStepMaxCooldown or 10
    PlayerData.shadowStep.isActive = false
    UIModule.updateAbilityButtons()
    DataModule.savePlayerData(PlayerData)
end

function AbilityModule.performDash()
    if not rootPart or not humanoid then return end
    
    local camera = workspace.CurrentCamera
    local lookVector = camera.CFrame.LookVector
    
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(4000, 0, 4000)
    bodyVelocity.Velocity = lookVector * (_G.dashSpeed or 50)
    bodyVelocity.Parent = rootPart

    FollowController:signalMovementOverride()

    Debris:AddItem(bodyVelocity, 0.3)
end

function AbilityModule.activateRampage()
    if PlayerData.rampage.isActive
        or PlayerData.rampage.cooldown > 0
        or not PlayerData.rampage.unlocked
        or not rootPart
        or not AnimationLock:acquire("rampage", 7)
        or not InputAuthority:canUseAbility()
    then
        return
    end
    
    InputAuthority:lockSystem(7)

    task.spawn(function()
        EffectsModule.createRampageCutscene()
    end)

    task.wait(6.5)

    PlayerData.rampage.isActive = true

    local originalStats = {}
    for stat, value in pairs(PlayerData.stats) do
        originalStats[stat] = value
        PlayerData.stats[stat] = Config.MAX_STAT_VALUE
    end

    humanoid.WalkSpeed = Config.MAX_WALK_SPEED
    PlayerData.shadowStep.cooldown = 0

    UIModule.updateAbilityButtons()

    task.spawn(function()
        EffectsModule.createRampageAura()
    end)

    task.wait(PlayerData.rampage.duration)

    PlayerData.rampage.isActive = false

    for stat, value in pairs(originalStats) do
        PlayerData.stats[stat] = value
    end

    StatCalculator.applyStatEffects()

    PlayerData.behindYou.cooldown = 0
    PlayerData.rampage.cooldown = PlayerData.rampage.maxCooldown
    PlayerData.rampage.currentKills = 0

    UIModule.updateAbilityButtons()
    DataModule.savePlayerData(PlayerData)
end

function AbilityModule.performBehindYou()
    if not PlayerData.rampage.isActive
        or PlayerData.behindYou.cooldown > 0
        or not rootPart
        or not AnimationLock:acquire("behind_you", 1.5)
        or not InputAuthority:canUseAbility()
    then
        return
    end
    
    InputAuthority:lockAbilities(1.5)

    local nearestPlayer, nearestDistance = nil, math.huge

    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherRoot then
                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                if distance >= Config.BEHIND_YOU_MIN_RANGE
                    and distance <= Config.BEHIND_YOU_MAX_RANGE
                    and distance < nearestDistance
                then
                    nearestDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end

    if not nearestPlayer then return end

    local targetRoot = nearestPlayer.Character.HumanoidRootPart
    local startPos = rootPart.Position
    local targetPos = targetRoot.Position - (targetRoot.CFrame.LookVector * 5)

    task.spawn(function()
        EffectsModule.createBehindYouEffect(startPos, targetPos)
    end)

    task.wait(0.15)

    rootPart.CFrame = CFrame.new(targetPos, targetRoot.Position)
    FollowController:signalMovementOverride()

    PlayerData.behindYou.cooldown = PlayerData.behindYou.maxCooldown
    UIModule.updateAbilityButtons()
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ–¥ï¸ UI MODULE (ENHANCED WITH IN-WORLD DESCRIPTIONS)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

UIModule = {}

local mainPart
local isVisible = false
local acceptedNotification = false
local levelValueLabel, xpBar, xpTextLabel, rankLabel, titleLabel, pointsValueLabel
local hpBar, hpTextLabel, shadowStepButton, cooldownBar, statsButton
local ssLevelLabel, classLabel, statusLabel, rampageButton, behindYouButton, rampageKillLabel

function UIModule.createRoundedFrame(parent, size, position, bgColor, transparency)
    local frame = Instance.new("Frame")
    frame.Size = size
    frame.Position = position
    frame.BackgroundColor3 = bgColor
    frame.BackgroundTransparency = transparency or 0
    frame.BorderSizePixel = 0
    frame.Parent = parent
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = frame
    
    return frame
end

function UIModule.createTextLabel(parent, text, size, position, textColor, fontSize, font, alignment)
    local label = Instance.new("TextLabel")
    label.Text = text
    label.Size = size
    label.Position = position
    label.TextColor3 = textColor or Color3.fromRGB(255, 255, 255)
    label.Font = font or Enum.Font.GothamBold
    label.TextSize = fontSize or 24
    label.BackgroundTransparency = 1
    label.TextXAlignment = alignment or Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.TextWrapped = true
    label.Parent = parent
    
    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(0, 0, 0)
    stroke.Transparency = 0.3
    stroke.Parent = label
    
    return label
end

function UIModule.createButton(parent, text, size, position, bgColor, textColor, fontSize, callback)
    local button = Instance.new("TextButton")
    button.Text = text
    button.Size = size
    button.Position = position
    button.BackgroundColor3 = bgColor
    button.TextColor3 = textColor
    button.Font = Enum.Font.GothamBold
    button.TextSize = fontSize
    button.BorderSizePixel = 0
    button.AutoButtonColor = false
    button.Parent = parent
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = button
    
    if callback then
        button.MouseButton1Click:Connect(callback)
        button.TouchTap:Connect(callback)
    end

    button.MouseEnter:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.new(
                math.min(bgColor.R + 0.2, 1),
                math.min(bgColor.G + 0.2, 1),
                math.min(bgColor.B + 0.2, 1)
            )
        }):Play()
    end)

    button.MouseLeave:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = bgColor
        }):Play()
    end)

    return button
end

function UIModule.updateUI()
    if not acceptedNotification then return end
    
    if levelValueLabel then
        levelValueLabel.Text = PlayerData.level .. "/" .. Config.LEVEL_CAP
    end
    
    if xpBar and xpTextLabel then
        local maxXP = LevelSystem.calculateRequiredXP(PlayerData.level)
        local progress = math.clamp(PlayerData.xp / maxXP, 0, 1)
        TweenService:Create(xpBar, TweenInfo.new(0.35), {
            Size = UDim2.new(progress, 0, 1, 0)
        }):Play()
        xpTextLabel.Text = "EXP: " .. PlayerData.xp .. "/" .. maxXP
    end
    
    if hpBar and hpTextLabel and humanoid then
        local hpPercent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
        TweenService:Create(hpBar, TweenInfo.new(0.2), {
            Size = UDim2.new(hpPercent, 0, 1, 0)
        }):Play()
        hpTextLabel.Text = math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth)
    end
    
    if pointsValueLabel then
        pointsValueLabel.Text = tostring(PlayerData.availablePoints)
    end
    
    local currentRank = LevelSystem.getCurrentRank()
    if rankLabel then
        rankLabel.Text = currentRank.name
        rankLabel.TextColor3 = currentRank.color
    end
    
    if titleLabel then titleLabel.Text = currentRank.title:upper() end
    if classLabel then classLabel.Text = LevelSystem.getCurrentClass():upper() end
    if statusLabel then statusLabel.Text = currentRank.status end
    if ssLevelLabel then ssLevelLabel.Text = "LV " .. PlayerData.shadowStep.level end
    
    if rampageKillLabel then
        if PlayerData.rampage.cooldown > 0 then
            rampageKillLabel.Text = string.format("KILLS: %d/%d", PlayerData.rampage.currentKills, PlayerData.rampage.killsRequired)
            rampageKillLabel.Visible = true
        else
            rampageKillLabel.Visible = false
        end
    end
end

function UIModule.updateAbilityButtons()
    if shadowStepButton and PlayerData.shadowStep.unlocked then
        shadowStepButton.Visible = true
        if PlayerData.shadowStep.cooldown > 0 then
            shadowStepButton.BackgroundColor3 = Color3.fromRGB(51, 51, 51)
            shadowStepButton.TextColor3 = Color3.fromRGB(150, 150, 150)
        else
            shadowStepButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            shadowStepButton.TextColor3 = Color3.fromRGB(138, 43, 226)
        end
        
        if cooldownBar then
            local progress = PlayerData.shadowStep.cooldown > 0
                and (1 - (PlayerData.shadowStep.cooldown / (_G.shadowStepMaxCooldown or 10)))
                or 1
            cooldownBar.Size = UDim2.new(progress, 0, 0, 4)
        end
    end
    
    if rampageButton and PlayerData.rampage.unlocked then
        rampageButton.Visible = true
        
        if PlayerData.rampage.cooldown > 0 or PlayerData.rampage.isActive then
            rampageButton.BackgroundColor3 = Color3.fromRGB(70, 0, 0)
            rampageButton.TextColor3 = Color3.fromRGB(150, 150, 150)
            rampageButton.Text = PlayerData.rampage.cooldown > 0
                and string.format("%.0fs", PlayerData.rampage.cooldown)
                or "ACTIVE"
        else
            rampageButton.BackgroundColor3 = Color3.fromRGB(139, 0, 0)
            rampageButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            rampageButton.Text = "RAGE"
        end
    end
    
    if behindYouButton then
        behindYouButton.Visible = PlayerData.rampage.isActive
        
        if PlayerData.behindYou.cooldown > 0 then
            behindYouButton.BackgroundColor3 = Color3.fromRGB(40, 0, 65)
            behindYouButton.TextColor3 = Color3.fromRGB(150, 150, 150)
        else
            behindYouButton.BackgroundColor3 = Color3.fromRGB(75, 0, 130)
            behindYouButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        end
    end
end

-- Enhanced Description System (In-World, not ScreenGui)
function UIModule.showStatDescription(statData)
    if not StateManager:canInteract() then
        return
    end
    
    if StateManager.activeDescription then
        UIModule.closeAllDescriptions()
        return
    end
    
    if not mainPart or not rootPart then return end
    if not AnimationLock:acquire("description", 0.5) then
        return
    end
    
    -- Create description part in world space
    local descPart = Instance.new("Part")
    descPart.Name = "StatDescriptionPart"
    descPart.Size = Vector3.new(12, 9, 0.2)
    descPart.CFrame = mainPart.CFrame * CFrame.new(0, 0, 2.5)
    descPart.Anchored = true
    descPart.CanCollide = false
    descPart.Transparency = 0.05
    descPart.Material = Enum.Material.ForceField
    descPart.Parent = workspace
    
    FollowController:setDescriptionPart(descPart)
    
    local surfaceGui = Instance.new("SurfaceGui")
    surfaceGui.Face = Enum.NormalId.Front
    surfaceGui.CanvasSize = Vector2.new(1200, 900)
    surfaceGui.LightInfluence = 0
    surfaceGui.Brightness = 2
    surfaceGui.AlwaysOnTop = true
    surfaceGui.Parent = descPart
    
    local descFrame = UIModule.createRoundedFrame(
        surfaceGui,
        UDim2.new(0, 0, 0, 0),
        UDim2.new(0.5, 0, 0.5, 0),
        Color3.fromRGB(15, 20, 35),
        0
    )
    descFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    
    TweenService:Create(descFrame, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = UDim2.new(1, 0, 1, 0)
    }):Play()
    
    local frameStroke = Instance.new("UIStroke")
    frameStroke.Color = statData.color
    frameStroke.Thickness = 8
    frameStroke.Parent = descFrame
    
    local titleBar = UIModule.createRoundedFrame(
        descFrame,
        UDim2.new(1, 0, 0, 90),
        UDim2.new(0, 0, 0, 0),
        statData.color,
        0
    )
    
    UIModule.createTextLabel(
        titleBar,
        statData.title,
        UDim2.new(1, -20, 1, 0),
        UDim2.new(0, 10, 0, 0),
        Color3.fromRGB(255, 255, 255),
        32,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Center
    )
    
    -- Scrolling frame for long descriptions
    local scrollFrame = Instance.new("ScrollingFrame")
    scrollFrame.Size = UDim2.new(1, -60, 0, 680)
    scrollFrame.Position = UDim2.new(0, 30, 0, 110)
    scrollFrame.BackgroundTransparency = 1
    scrollFrame.BorderSizePixel = 0
    scrollFrame.ScrollBarThickness = 8
    scrollFrame.ScrollBarImageColor3 = statData.color
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
    scrollFrame.Parent = descFrame
    
    local descText = UIModule.createTextLabel(
        scrollFrame,
        statData.description,
        UDim2.new(1, -20, 0, 0),
        UDim2.new(0, 10, 0, 10),
        Color3.fromRGB(220, 220, 220),
        20,
        Enum.Font.Gotham,
        Enum.TextXAlignment.Left
    )
    descText.TextYAlignment = Enum.TextYAlignment.Top
    descText.AutomaticSize = Enum.AutomaticSize.Y
    
    UIModule.createButton(
        descFrame,
        "CLOSE",
        UDim2.new(0, 300, 0, 60),
        UDim2.new(0.5, -150, 1, -80),
        Color3.fromRGB(51, 65, 85),
        Color3.fromRGB(255, 255, 255),
        24,
        function()
            UIModule.closeAllDescriptions()
        end
    )
    
    StateManager.activeDescription = descPart
    
    -- Auto-close after 15 seconds
    task.delay(15, function()
        if StateManager.activeDescription == descPart then
            UIModule.closeAllDescriptions()
        end
    end)
end

-- Show ability description in-world
function UIModule.showAbilityDescription(abilityName)
    if not StateManager:canInteract() then
        return
    end
    
    if StateManager.activeDescription then
        UIModule.closeAllDescriptions()
        return
    end
    
    if not mainPart or not rootPart then return end
    if not AnimationLock:acquire("description", 0.5) then
        return
    end
    
    local abilityInfo = AbilityCodex:getAbilityInfo(abilityName, PlayerData)
    if not abilityInfo then return end
    
    -- Create description part in world space
    local descPart = Instance.new("Part")
    descPart.Name = "AbilityDescriptionPart"
    descPart.Size = Vector3.new(14, 10, 0.2)
    descPart.CFrame = mainPart.CFrame * CFrame.new(0, 0, 2.5)
    descPart.Anchored = true
    descPart.CanCollide = false
    descPart.Transparency = 0.05
    descPart.Material = Enum.Material.ForceField
    descPart.Parent = workspace
    
    FollowController:setDescriptionPart(descPart)
    
    local surfaceGui = Instance.new("SurfaceGui")
    surfaceGui.Face = Enum.NormalId.Front
    surfaceGui.CanvasSize = Vector2.new(1400, 1000)
    surfaceGui.LightInfluence = 0
    surfaceGui.Brightness = 2
    surfaceGui.AlwaysOnTop = true
    surfaceGui.Parent = descPart
    
    local descFrame = UIModule.createRoundedFrame(
        surfaceGui,
        UDim2.new(0, 0, 0, 0),
        UDim2.new(0.5, 0, 0.5, 0),
        Color3.fromRGB(15, 20, 35),
        0
    )
    descFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    
    TweenService:Create(descFrame, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = UDim2.new(1, 0, 1, 0)
    }):Play()
    
    local frameStroke = Instance.new("UIStroke")
    frameStroke.Color = Color3.fromRGB(138, 43, 226)
    frameStroke.Thickness = 8
    frameStroke.Parent = descFrame
    
    local titleBar = UIModule.createRoundedFrame(
        descFrame,
        UDim2.new(1, 0, 0, 100),
        UDim2.new(0, 0, 0, 0),
        Color3.fromRGB(138, 43, 226),
        0
    )
    
    UIModule.createTextLabel(
        titleBar,
        abilityInfo.name:upper(),
        UDim2.new(1, -20, 0, 50),
        UDim2.new(0, 10, 0, 10),
        Color3.fromRGB(255, 255, 255),
        36,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Center
    )
    
    UIModule.createTextLabel(
        titleBar,
        abilityInfo.category .. " â€¢ Unlock: Level " .. abilityInfo.unlockLevel,
        UDim2.new(1, -20, 0, 30),
        UDim2.new(0, 10, 0, 60),
        Color3.fromRGB(200, 200, 200),
        18,
        Enum.Font.Gotham,
        Enum.TextXAlignment.Center
    )
    
    -- Scrolling frame for long descriptions
    local scrollFrame = Instance.new("ScrollingFrame")
    scrollFrame.Size = UDim2.new(1, -60, 0, 780)
    scrollFrame.Position = UDim2.new(0, 30, 0, 120)
    scrollFrame.BackgroundTransparency = 1
    scrollFrame.BorderSizePixel = 0
    scrollFrame.ScrollBarThickness = 10
    scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(138, 43, 226)
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
    scrollFrame.Parent = descFrame
    
    local descText = UIModule.createTextLabel(
        scrollFrame,
        abilityInfo.description,
        UDim2.new(1, -20, 0, 0),
        UDim2.new(0, 10, 0, 10),
        Color3.fromRGB(220, 220, 220),
        18,
        Enum.Font.Gotham,
        Enum.TextXAlignment.Left
    )
    descText.TextYAlignment = Enum.TextYAlignment.Top
    descText.AutomaticSize = Enum.AutomaticSize.Y
    
    UIModule.createButton(
        descFrame,
        "CLOSE",
        UDim2.new(0, 350, 0, 70),
        UDim2.new(0.5, -175, 1, -90),
        Color3.fromRGB(51, 65, 85),
        Color3.fromRGB(255, 255, 255),
        26,
        function()
            UIModule.closeAllDescriptions()
        end
    )
    
    StateManager.activeDescription = descPart
    
    -- Auto-close after 20 seconds
    task.delay(20, function()
        if StateManager.activeDescription == descPart then
            UIModule.closeAllDescriptions()
        end
    end)
end

function UIModule.closeAllDescriptions()
    if StateManager.activeDescription then
        local descToClose = StateManager.activeDescription
        local surfaceGui = descToClose:FindFirstChildOfClass("SurfaceGui")
        if surfaceGui then
            local frame = surfaceGui:FindFirstChild("Frame")
            if frame then
                TweenService:Create(frame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
                    Size = UDim2.new(0, 0, 0, 0)
                }):Play()
            end
        end
        
        TweenService:Create(descToClose, TweenInfo.new(0.3), {
            Transparency = 1
        }):Play()
        
        task.delay(0.3, function()
            if descToClose and descToClose.Parent then
                descToClose:Destroy()
            end
        end)
        
        StateManager.activeDescription = nil
        FollowController:setDescriptionPart(nil)
    end
end

function UIModule.createMainUI()
    local hrp = character:WaitForChild("HumanoidRootPart")
    mainPart = Instance.new("Part")
    mainPart.Name = "StatSystemObject"
    mainPart.Size = Vector3.new(14, 8, 0.2)
    
    local characterLook = hrp.CFrame.LookVector
    mainPart.CFrame = CFrame.new(hrp.Position + (characterLook * 8) + Vector3.new(0, 2, 0), hrp.Position)
    
    mainPart.Anchored = true
    mainPart.CanCollide = false
    mainPart.Transparency = 1
    mainPart.Material = Enum.Material.ForceField
    mainPart.Parent = workspace
    
    FollowController:initialize(mainPart)
    
    local surfaceGui = Instance.new("SurfaceGui")
    surfaceGui.Face = Enum.NormalId.Front
    surfaceGui.CanvasSize = Vector2.new(1400, 800)
    surfaceGui.LightInfluence = 0
    surfaceGui.Brightness = 2
    surfaceGui.Enabled = false
    surfaceGui.AlwaysOnTop = true
    surfaceGui.Parent = mainPart
    
    -- Create toggle buttons
    local playerGui = player:WaitForChild("PlayerGui")
    local toggleGui = Instance.new("ScreenGui")
    toggleGui.Name = "StatToggleGui"
    toggleGui.ResetOnSpawn = false
    toggleGui.Parent = playerGui
    
    local buttonContainer = Instance.new("Frame")
    buttonContainer.Size = UDim2.new(0, 65, 0, 225)
    buttonContainer.Position = UDim2.new(0, 20, 0.5, -112)
    buttonContainer.BackgroundTransparency = 1
    buttonContainer.Parent = toggleGui
    
    statsButton = UIModule.createButton(
        buttonContainer,
        "STATS",
        UDim2.new(0, 60, 0, 60),
        UDim2.new(0, 2, 0, 0),
        Color3.fromRGB(8, 145, 178),
        Color3.fromRGB(255, 255, 255),
        20,
        function()
            if AnimationLock:isLocked("ui_toggle") then return end
            if not InputAuthority:canInteractUI() then return end
            if not AnimationLock:acquire("ui_toggle", 0.8) then return end
            
            isVisible = not isVisible
            
            if isVisible then
                InputAuthority:lockUI(0.5)
                StateManager:setState("OPENING", 0.5)
                FollowController:forceResync()
                
                mainPart.Transparency = 0.05
                surfaceGui.Enabled = true
                local mainFrame = surfaceGui:FindFirstChild("MainFrame")
                if mainFrame then
                    mainFrame.Size = UDim2.new(1, 0, 0, 0)
                    TweenService:Create(mainFrame, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                        Size = UDim2.new(1, 0, 1, 0)
                    }):Play()
                end
                
                task.delay(0.5, function()
                    StateManager:setState("OPEN")
                end)
            else
                InputAuthority:lockUI(0.3)
                StateManager:setState("CLOSING", 0.3)
                UIModule.closeAllDescriptions()
                
                local mainFrame = surfaceGui:FindFirstChild("MainFrame")
                if mainFrame then
                    TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
                        Size = UDim2.new(1, 0, 0, 0)
}):Play()
end
task.delay(0.3, function()
                surfaceGui.Enabled = false
                mainPart.Transparency = 1
                StateManager:setState("CLOSED")
            end)
        end
    end
)

local statsCorner = Instance.new("UICorner")
statsCorner.CornerRadius = UDim.new(0, 10)
statsCorner.Parent = statsButton

shadowStepButton = UIModule.createButton(
    buttonContainer,
    "DASH",
    UDim2.new(0, 60, 0, 60),
    UDim2.new(0, 2, 0, 72),
    Color3.fromRGB(51, 51, 51),
    Color3.fromRGB(150, 150, 150),
    16,
    AbilityModule.performShadowStep
)
shadowStepButton.Visible = PlayerData.shadowStep.unlocked

local shadowCorner = Instance.new("UICorner")
shadowCorner.CornerRadius = UDim.new(0, 10)
shadowCorner.Parent = shadowStepButton

-- Add info button for Shadow Step
local ssInfoButton = UIModule.createButton(
    shadowStepButton,
    "?",
    UDim2.new(0, 18, 0, 18),
    UDim2.new(1, -20, 0, 2),
    Color3.fromRGB(30, 30, 30),
    Color3.fromRGB(138, 43, 226),
    14,
    function()
        UIModule.showAbilityDescription("ShadowStep")
    end
)

ssLevelLabel = UIModule.createTextLabel(
    shadowStepButton,
    "LV " .. PlayerData.shadowStep.level,
    UDim2.new(1, 0, 0, 18),
    UDim2.new(0, 0, 1, -20),
    Color3.fromRGB(138, 43, 226),
    11
)
ssLevelLabel.TextXAlignment = Enum.TextXAlignment.Center

cooldownBar = Instance.new("Frame")
cooldownBar.Size = UDim2.new(1, 0, 0, 4)
cooldownBar.Position = UDim2.new(0, 0, 1, -4)
cooldownBar.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
cooldownBar.BorderSizePixel = 0
cooldownBar.Parent = shadowStepButton

rampageButton = UIModule.createButton(
    buttonContainer,
    "RAGE",
    UDim2.new(0, 60, 0, 60),
    UDim2.new(0, 2, 0, 144),
    Color3.fromRGB(139, 0, 0),
    Color3.fromRGB(255, 255, 255),
    18,
    AbilityModule.activateRampage
)
rampageButton.Visible = PlayerData.rampage.unlocked

local rampageCorner = Instance.new("UICorner")
rampageCorner.CornerRadius = UDim.new(0, 10)
rampageCorner.Parent = rampageButton

-- Add info button for Rampage
local rampageInfoButton = UIModule.createButton(
    rampageButton,
    "?",
    UDim2.new(0, 18, 0, 18),
    UDim2.new(1, -20, 0, 2),
    Color3.fromRGB(30, 30, 30),
    Color3.fromRGB(255, 60, 60),
    14,
    function()
        UIModule.showAbilityDescription("Rampage")
    end
)

rampageKillLabel = UIModule.createTextLabel(
    rampageButton,
    string.format("%d/%d", PlayerData.rampage.currentKills, PlayerData.rampage.killsRequired),
    UDim2.new(1, 0, 0, 16),
    UDim2.new(0, 0, 1, -18),
    Color3.fromRGB(255, 215, 0),
    10
)
rampageKillLabel.TextXAlignment = Enum.TextXAlignment.Center
rampageKillLabel.TextScaled = true
rampageKillLabel.Visible = false

behindYouButton = UIModule.createButton(
    buttonContainer,
    "BEHIND\nYOU",
    UDim2.new(0, 60, 0, 60),
    UDim2.new(1, -65, 0, 144),
    Color3.fromRGB(75, 0, 130),
    Color3.fromRGB(255, 255, 255),
    14,
    AbilityModule.performBehindYou
)
behindYouButton.Visible = false

local behindCorner = Instance.new("UICorner")
behindCorner.CornerRadius = UDim.new(0, 10)
behindCorner.Parent = behindYouButton

-- Add info button for Behind You
local behindInfoButton = UIModule.createButton(
    behindYouButton,
    "?",
    UDim2.new(0, 18, 0, 18),
    UDim2.new(1, -20, 0, 2),
    Color3.fromRGB(30, 30, 30),
    Color3.fromRGB(138, 43, 226),
    14,
    function()
        UIModule.showAbilityDescription("BehindYou")
    end
)

-- Create main UI frame
local mainFrame = UIModule.createRoundedFrame(
    surfaceGui,
    UDim2.new(1, 0, 0, 0),
    UDim2.new(0, 0, 0, 0),
    Color3.fromRGB(10, 15, 30),
    0
)
mainFrame.Name = "MainFrame"

local mainStroke = Instance.new("UIStroke")
mainStroke.Color = Color3.fromRGB(6, 182, 212)
mainStroke.Thickness = 10
mainStroke.Parent = mainFrame

local titleSection = UIModule.createRoundedFrame(
    mainFrame,
    UDim2.new(1, 0, 0, 80),
    UDim2.new(0, 0, 0, 0),
    Color3.fromRGB(15, 20, 35),
    0
)

UIModule.createTextLabel(
    titleSection,
    "SYSTEM",
    UDim2.new(1, -40, 1, 0),
    UDim2.new(0, 20, 0, 0),
    Color3.fromRGB(6, 182, 212),
    42,
    Enum.Font.GothamBold,
    Enum.TextXAlignment.Center
)

-- HP Section
local hpSection = Instance.new("Frame")
hpSection.Size = UDim2.new(1, -60, 0, 60)
hpSection.Position = UDim2.new(0, 30, 0, 95)
hpSection.BackgroundTransparency = 1
hpSection.Parent = mainFrame

UIModule.createTextLabel(
    hpSection,
    "HP",
    UDim2.new(0, 60, 0, 32),
    UDim2.new(0, 0, 0, 14),
    Color3.fromRGB(239, 68, 68),
    28
)

local hpBarBg = UIModule.createRoundedFrame(
    hpSection,
    UDim2.new(0, 900, 0, 32),
    UDim2.new(0, 70, 0, 14),
    Color3.fromRGB(20, 25, 40),
    0
)

local hpBorder = Instance.new("UIStroke")
hpBorder.Color = Color3.fromRGB(239, 68, 68)
hpBorder.Thickness = 3
hpBorder.Parent = hpBarBg

hpBar = UIModule.createRoundedFrame(
    hpBarBg,
    UDim2.new(1, 0, 1, 0),
    UDim2.new(0, 0, 0, 0),
    Color3.fromRGB(220, 38, 38),
    0
)

hpTextLabel = UIModule.createTextLabel(
    hpBar,
    math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth),
    UDim2.new(1, -15, 1, 0),
    UDim2.new(0, 0, 0, 0),
    Color3.fromRGB(255, 255, 255),
    22,
    Enum.Font.GothamBold,
    Enum.TextXAlignment.Right
)

UIModule.createTextLabel(
    hpSection,
    "LV",
    UDim2.new(0, 50, 0, 32),
    UDim2.new(1, -180, 0, 14),
    Color3.fromRGB(150, 150, 150),
    24
)

levelValueLabel = UIModule.createTextLabel(
    hpSection,
    PlayerData.level .. "/" .. Config.LEVEL_CAP,
    UDim2.new(0, 125, 0, 32),
    UDim2.new(1, -125, 0, 14),
    Color3.fromRGB(255, 255, 255),
    24
)

-- XP Bar
local xpBarBg = UIModule.createRoundedFrame(
    mainFrame,
    UDim2.new(1, -60, 0, 22),
    UDim2.new(0, 30, 0, 167),
    Color3.fromRGB(20, 25, 40),
    0
)

local xpBorder = Instance.new("UIStroke")
xpBorder.Color = Color3.fromRGB(34, 211, 238)
xpBorder.Thickness = 3
xpBorder.Parent = xpBarBg

xpBar = UIModule.createRoundedFrame(
    xpBarBg,
    UDim2.new(PlayerData.xp / LevelSystem.calculateRequiredXP(PlayerData.level), 0, 1, 0),
    UDim2.new(0, 0, 0, 0),
    Color3.fromRGB(34, 211, 238),
    0
)

xpTextLabel = UIModule.createTextLabel(
    xpBarBg,
    "EXP: " .. PlayerData.xp .. "/" .. LevelSystem.calculateRequiredXP(PlayerData.level),
    UDim2.new(1, -12, 1, 0),
    UDim2.new(0, 12, 0, 0),
    Color3.fromRGB(255, 255, 255),
    18,
    Enum.Font.GothamBold,
    Enum.TextXAlignment.Left
)

-- Stats Container
local statsContainer = Instance.new("Frame")
statsContainer.Size = UDim2.new(1, -60, 0, 320)
statsContainer.Position = UDim2.new(0, 30, 0, 205)
statsContainer.BackgroundTransparency = 1
statsContainer.Parent = mainFrame

local function createStatRow(statKey, yPos, xPos)
    local stat = StatInfo[statKey]
    local statFrame = UIModule.createRoundedFrame(
        statsContainer,
        UDim2.new(0, 650, 0, 85),
        UDim2.new(0, xPos, 0, yPos),
        Color3.fromRGB(20, 25, 40),
        0
    )
    
    local statBorder = Instance.new("UIStroke")
    statBorder.Color = stat.color
    statBorder.Thickness = 3
    statBorder.Parent = statFrame
    
    local abbrBox = UIModule.createRoundedFrame(
        statFrame,
        UDim2.new(0, 90, 0, 55),
        UDim2.new(0, 15, 0, 15),
        Color3.fromRGB(15, 20, 35),
        0
    )
    
    local abbrBorder = Instance.new("UIStroke")
    abbrBorder.Color = stat.color
    abbrBorder.Thickness = 3
    abbrBorder.Parent = abbrBox
    
    UIModule.createTextLabel(
        abbrBox,
        stat.abbr,
        UDim2.new(1, 0, 1, 0),
        UDim2.new(0, 0, 0, 0),
        stat.color,
        26,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Center
    )
    
    UIModule.createTextLabel(
        statFrame,
        stat.name,
        UDim2.new(0, 180, 0, 40),
        UDim2.new(0, 115, 0, 22),
        Color3.fromRGB(220, 220, 220),
        24
    )
    
    local valueLabel = UIModule.createTextLabel(
        statFrame,
        tostring(PlayerData.stats[statKey]),
        UDim2.new(0, 65, 0, 40),
        UDim2.new(0, 300, 0, 22),
        Color3.fromRGB(255, 255, 255),
        32,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Center
    )
    
    local effectLabel = UIModule.createTextLabel(
        statFrame,
        stat.getEffect(PlayerData.stats[statKey]),
        UDim2.new(0, 160, 0, 26),
        UDim2.new(0, 375, 0, 29),
        stat.color,
        18,
        Enum.Font.Gotham,
        Enum.TextXAlignment.Left
    )
    
    UIModule.createButton(
        statFrame,
        "?",
        UDim2.new(0, 35, 0, 35),
        UDim2.new(0, 540, 0, 25),
        Color3.fromRGB(30, 35, 50),
        Color3.fromRGB(200, 200, 200),
        22,
        function()
            UIModule.showStatDescription(stat)
        end
    )
    
    UIModule.createButton(
        statFrame,
        "+",
        UDim2.new(0, 45, 0, 45),
        UDim2.new(0, 585, 0, 20),
        Color3.fromRGB(51, 65, 85),
        stat.color,
        30,
        function()
            if PlayerData.availablePoints > 0 and PlayerData.stats[statKey] < Config.MAX_STAT_VALUE then
                PlayerData.stats[statKey] = math.min(PlayerData.stats[statKey] + 1, Config.MAX_STAT_VALUE)
                PlayerData.availablePoints = PlayerData.availablePoints - 1
                
                StatCalculator.applyStatEffects()
                task.spawn(function()
                    EffectsModule.createStatUpgradeEffect(statKey)
                end)
                
                valueLabel.Text = tostring(PlayerData.stats[statKey])
                effectLabel.Text = stat.getEffect(PlayerData.stats[statKey])
                UIModule.updateUI()
            end
        end
    )
end

createStatRow("strength", 0, 0)
createStatRow("agility", 95, 0)
createStatRow("perception", 190, 0)
createStatRow("vitality", 0, 700)
createStatRow("intelligence", 95, 700)

-- Points Box
local pointsBox = UIModule.createRoundedFrame(
    statsContainer,
    UDim2.new(0, 650, 0, 75),
    UDim2.new(0, 700, 0, 200),
    Color3.fromRGB(20, 30, 50),
    0
)

local pointsStroke = Instance.new("UIStroke")
pointsStroke.Color = Color3.fromRGB(34, 211, 238)
pointsStroke.Thickness = 5
pointsStroke.Parent = pointsBox

UIModule.createTextLabel(
    pointsBox,
    "Available Points",
    UDim2.new(0, 380, 1, 0),
    UDim2.new(0, 30, 0, 0),
    Color3.fromRGB(220, 220, 220),
    26
)

pointsValueLabel = UIModule.createTextLabel(
    pointsBox,
    tostring(PlayerData.availablePoints),
    UDim2.new(0, 220, 1, 0),
    UDim2.new(1, -240, 0, 0),
    Color3.fromRGB(34, 211, 238),
    38,
    Enum.Font.GothamBold,
    Enum.TextXAlignment.Center
)

-- Info Container
local infoContainer = Instance.new("Frame")
infoContainer.Size = UDim2.new(1, -60, 0, 160)
infoContainer.Position = UDim2.new(0, 30, 0, 540)
infoContainer.BackgroundTransparency = 1
infoContainer.Parent = mainFrame

local function createInfoRow(label, value, xPos, yPos, valueColor)
    UIModule.createTextLabel(
        infoContainer,
        label,
        UDim2.new(0, 160, 0, 50),
        UDim2.new(0, xPos, 0, yPos),
        Color3.fromRGB(160, 160, 160),
        24
    )
    
    local valueText = UIModule.createTextLabel(
        infoContainer,
        value,
        UDim2.new(0, 470, 0, 50),
        UDim2.new(0, xPos + 165, 0, yPos),
        valueColor,
        26,
        Enum.Font.GothamBold,
        Enum.TextXAlignment.Right
    )
    valueText.TextScaled = true
    return valueText
end

local currentRank = LevelSystem.getCurrentRank()
rankLabel = createInfoRow("RANK", currentRank.name, 0, 10, currentRank.color)
classLabel = createInfoRow("CLASS", LevelSystem.getCurrentClass():upper(), 0, 58, Color3.fromRGB(168, 85, 247))
titleLabel = createInfoRow("TITLE", currentRank.title:upper(), 680, 10, Color3.fromRGB(248, 113, 113))
statusLabel = createInfoRow("STATUS", currentRank.status, 680, 58, Color3.fromRGB(34, 211, 238))

UIModule.updateUI()
end
function UIModule.createInitialNotification()
local notifPart = Instance.new("Part")
notifPart.Name = "NotificationPart"
notifPart.Size = Vector3.new(12, 7, 0.2)
local characterLook = rootPart.CFrame.LookVector
notifPart.CFrame = CFrame.new(rootPart.Position + (characterLook * 8) + Vector3.new(0, 3, 0), rootPart.Position)
notifPart.Anchored = true
notifPart.CanCollide = false
notifPart.Transparency = 0.05
notifPart.Material = Enum.Material.ForceField
notifPart.Parent = workspace

local surfaceGui = Instance.new("SurfaceGui")
surfaceGui.Face = Enum.NormalId.Front
surfaceGui.CanvasSize = Vector2.new(1200, 700)
surfaceGui.LightInfluence = 0
surfaceGui.Brightness = 2
surfaceGui.AlwaysOnTop = true
surfaceGui.Parent = notifPart

local bg = UIModule.createRoundedFrame(
    surfaceGui,
    UDim2.new(1, 0, 1, 0),
    UDim2.new(0, 0, 0, 0),
    Color3.fromRGB(10, 15, 30),
    0
)

local stroke = Instance.new("UIStroke")
stroke.Color = Color3.fromRGB(6, 182, 212)
stroke.Thickness = 10
stroke.Parent = bg

UIModule.createTextLabel(
    bg,
    "SYSTEM NOTIFICATION",
    UDim2.new(1, -40, 0, 90),
    UDim2.new(0, 20, 0, 35),
    Color3.fromRGB(6, 182, 212),
    44,
    Enum.Font.GothamBold,
    Enum.TextXAlignment.Center
)

UIModule.createTextLabel(
    bg,
    "You have acquired the qualifications\nto become a Player.\n\nThe System has recognized your potential.\nWill you accept this power?",
    UDim2.new(1, -80, 0, 180),
    UDim2.new(0, 40, 0, 145),
    Color3.fromRGB(220, 220, 220),
    26,
    Enum.Font.Gotham,
    Enum.TextXAlignment.Center
)

UIModule.createButton(
    bg,
    "ACCEPT",
    UDim2.new(0, 380, 0, 90),
    UDim2.new(0, 80, 1, -130),
    Color3.fromRGB(8, 145, 178),
    Color3.fromRGB(255, 255, 255),
    32,
    function()
        acceptedNotification = true
        TweenService:Create(notifPart, TweenInfo.new(0.3), {Transparency = 1}):Play()
        task.wait(0.3)
        notifPart:Destroy()
        UIModule.createMainUI()
    end
)

UIModule.createButton(
    bg,
    "DECLINE",
    UDim2.new(0, 380, 0, 90),
    UDim2.new(1, -460, 1, -130),
    Color3.fromRGB(51, 65, 85),
    Color3.fromRGB(255, 255, 255),
    32,
    function()
        acceptedNotification = false
        TweenService:Create(notifPart, TweenInfo.new(0.3), {Transparency = 1}):Play()
        task.wait(0.3)
        notifPart:Destroy()
    end
)

-- Follow character smoothly
task.spawn(function()
    local t = 0
    while notifPart and notifPart.Parent do
        t = t + task.wait(0.05)
        local bobY = math.sin(t * 2) * 0.3
        
        if character and character:FindFirstChild("HumanoidRootPart") then
            local hrp = character.HumanoidRootPart
            local charLook = hrp.CFrame.LookVector
            local targetPos = hrp.Position + (charLook * 8) + Vector3.new(0, 3 + bobY, 0)
            local lookAtPos = Vector3.new(hrp.Position.X, notifPart.Position.Y, hrp.Position.Z)
            notifPart.CFrame = notifPart.CFrame:Lerp(CFrame.new(targetPos, lookAtPos), 0.12)
        end
    end
end)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ® PLAYER MONITORING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function monitorPlayers()
pcall(function()
for _, otherPlayer in pairs(Players:GetPlayers()) do
if otherPlayer ~= player and otherPlayer.Character then
CombatModule.setupHealthMonitoring(otherPlayer)
end
end
end)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ”„ UNIFIED UPDATE LOOP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function startUnifiedUpdateLoop()
local accumulators = {ui = 0, regen = 0, cleanup = 0, monitor = 0, autosave = 0}
local updateInterval = PhoneOptimizer:getUpdateInterval()
RunService.Heartbeat:Connect(function(deltaTime)
    pcall(function()
        accumulators.ui = accumulators.ui + deltaTime
        if accumulators.ui >= updateInterval then
            accumulators.ui = 0
            
            local shouldUpdateUI = acceptedNotification and (isVisible or PlayerData.shadowStep.cooldown > 0 or PlayerData.rampage.cooldown > 0)
            
            if PlayerData.shadowStep.cooldown > 0 then
                PlayerData.shadowStep.cooldown = math.max(0, PlayerData.shadowStep.cooldown - updateInterval)
                if shouldUpdateUI then
                    UIModule.updateAbilityButtons()
                end
            end
            
            if PlayerData.rampage.cooldown > 0 then
                PlayerData.rampage.cooldown = math.max(0, PlayerData.rampage.cooldown - updateInterval)
                if shouldUpdateUI then
                    UIModule.updateAbilityButtons()
                end
            end
            
            if PlayerData.behindYou.cooldown > 0 then
                PlayerData.behindYou.cooldown = math.max(0, PlayerData.behindYou.cooldown - updateInterval)
                if shouldUpdateUI then
                    UIModule.updateAbilityButtons()
                end
            end
        end
        
        accumulators.regen = accumulators.regen + deltaTime
        if accumulators.regen >= 1 then
            accumulators.regen = 0
            if humanoid and humanoid.Health > 0 and humanoid.Health < humanoid.MaxHealth then
                local regenAmount = PlayerData.stats.vitality * Config.STAT_CURVES.vitality.regenPerPoint
                if regenAmount > 0 then
                    humanoid.Health = math.min(humanoid.Health + regenAmount, humanoid.MaxHealth)
                    if isVisible then
                        UIModule.updateUI()
                    end
                end
            end
        end
        
        accumulators.cleanup = accumulators.cleanup + deltaTime
        if accumulators.cleanup >= 5 then
            accumulators.cleanup = 0
            local currentTime = tick()
            
            for userId, engagement in pairs(PlayerData.combatEngagement) do
                if currentTime - engagement.lastHit > Config.COMBAT_TIMEOUT then
                    PlayerData.combatEngagement[userId] = nil
                end
            end
            
            for userId, assist in pairs(PlayerData.assistEngagement) do
                if currentTime - assist.lastSeen > Config.ASSIST_TIME_WINDOW then
                    PlayerData.assistEngagement[userId] = nil
                end
            end
        end
        
        accumulators.monitor = accumulators.monitor + deltaTime
        if accumulators.monitor >= 2 then
            accumulators.monitor = 0
            monitorPlayers()
        end
        
        -- Auto-save every 30 seconds
        accumulators.autosave = accumulators.autosave + deltaTime
        if accumulators.autosave >= 30 then
            accumulators.autosave = 0
            DataModule.savePlayerData(PlayerData)
        end
    end)
end)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ›¡ï¸ SECOND CHANCE SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function setupSecondChance()
if not humanoid then return end
humanoid.Died:Connect(function()
    if PlayerData.hasSecondChance and PlayerData.stats.vitality >= Config.STAT_CURVES.vitality.secondChanceThreshold then
        task.wait(0.1)
        if humanoid and humanoid.Health <= 0 then
            humanoid.Health = PlayerData.maxHP * 0.5
            PlayerData.hasSecondChance = false
            
            task.spawn(function()
                EffectsModule.createSecondChanceEffect()
                NotificationQueue:add({
                    text = "SECOND CHANCE",
                    offset = Vector3.new(0, 3, 0),
                    duration = 1.5,
                    color = Color3.fromRGB(168, 85, 247)
                })
            end)
            
            task.wait(60)
            PlayerData.hasSecondChance = true
            if PlayerData.stats.vitality >= Config.STAT_CURVES.vitality.secondChanceThreshold then
                NotificationQueue:add({
                    text = "SECOND CHANCE READY",
                    offset = Vector3.new(0, 3, 0),
                    duration = 1.5,
                    color = Color3.fromRGB(168, 85, 247)
                })
            end
        end
    end
end)

humanoid.HealthChanged:Connect(function()
    if isVisible then
        UIModule.updateUI()
    end
end)

humanoid:GetPropertyChangedSignal("MaxHealth"):Connect(function()
    if isVisible then
        UIModule.updateUI()
    end
end)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âŒ¨ï¸ INPUT HANDLING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function setupInputHandling()
UserInputService.InputBegan:Connect(function(input, gameProcessed)
if gameProcessed then return end
if not InputAuthority:canUseAbility() then return end
if input.KeyCode == Enum.KeyCode.E then
        AbilityModule.performShadowStep()
    end
    
    if input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.RightShift then
AbilityModule.performDash()
end
if input.KeyCode == Enum.KeyCode.R then
        AbilityModule.activateRampage()
    end
    
    if input.KeyCode == Enum.KeyCode.F then
        AbilityModule.performBehindYou()
    end
    
    -- Export data command
    if input.KeyCode == Enum.KeyCode.P and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
        DataModule.exportData()
        print("âœ… Data exported successfully!")
    end
end)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ”„ CHARACTER RESPAWN HANDLING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
player.CharacterAdded:Connect(function(newCharacter)
character = newCharacter
humanoid = newCharacter:WaitForChild("Humanoid")
rootPart = newCharacter:WaitForChild("HumanoidRootPart")
humanoid.MaxHealth = PlayerData.maxHP
humanoid.Health = PlayerData.maxHP

if PlayerData.stats.vitality >= Config.STAT_CURVES.vitality.secondChanceThreshold then
    PlayerData.hasSecondChance = true
end

task.wait(0.2)
StatCalculator.applyStatEffects()
UIModule.updateUI()

if acceptedNotification and mainPart then
    task.wait(0.5)
    FollowController:forceResync()
end

setupSecondChance()
end)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸš€ INITIALIZATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function initialize()
pcall(function()
StatCalculator.applyStatEffects()
if humanoid then
        humanoid.MaxHealth = PlayerData.maxHP
        humanoid.Health = PlayerData.maxHP
    end
    
    setupInputHandling()
    setupSecondChance()
    
    task.defer(function()
        startUnifiedUpdateLoop()
        monitorPlayers()
        
        Players.PlayerAdded:Connect(function()
            task.wait(1)
            monitorPlayers()
        end)
    end)
    
    task.wait(0.5)
    UIModule.createInitialNotification()
    
    -- Print system info
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("âš¡ SOLO LEVELING SYSTEM INITIALIZED")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("ğŸ“ Data File: " .. SAVE_FILE)
    print("ğŸ“Š Level: " .. PlayerData.level .. "/" .. Config.LEVEL_CAP)
    print("ğŸ’ª Available Points: " .. PlayerData.availablePoints)
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print("\nABILITY INFORMATION:")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    
    for abilityName, _ in pairs(AbilityCodex) do
        if abilityName ~= "getAbilityInfo" then
            local info = AbilityCodex:getAbilityInfo(abilityName, PlayerData)
            if info then
                print("\nğŸ“– " .. info.name .. " (" .. info.category .. ")")
                print("   Unlock Level: " .. info.unlockLevel)
                print("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
            end
        end
    end
    
    print("\nğŸ® CONTROLS:")
    print("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    print("E - Shadow Step")
    print("Shift - Dash")
    print("R - Rampage")
    print("F - Behind You (Rampage Only)")
    print("Ctrl+P - Export Data")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end)
end
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- â–¶ï¸ START SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
initialize()
